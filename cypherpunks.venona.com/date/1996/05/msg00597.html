<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: Transitive trust and MLM -->
<!--X-From-R13: ryv+NUE160.EB.QE.Q[G.SRG -->
<!--X-Date: Sat, 11 May 1996 12:16:36 +0800 -->
<!--X-Message-Id: 199605100209.TAA14299@cygnus.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: +cmu.andrew.internet.cypherpunks+IlYDbnW00UfAI10=1K@andrew.cmu.edu -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: Transitive trust and MLM</TITLE>
<LINK REV="made" HREF="mailto:eli+@GS160.SP.CS.CMU.EDU">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00626.html">Date Prev</A>][<A HREF="msg00628.html">Date Next</A>][<A HREF="msg00585.html">Thread Prev</A>][<A HREF="msg00636.html">Thread Next</A>][<A HREF="index.html#00597">Date Index</A>][<A HREF="threads.html#00597">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: Transitive trust and MLM</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Subject</em>: Re: Transitive trust and MLM</LI>
<LI><em>From</em>: <A HREF="mailto:eli%2B@GS160.SP.CS.CMU.EDU">eli+@GS160.SP.CS.CMU.EDU</A></LI>
<LI><em>Date</em>: Thu, 9 May 96 22:09:40 EDT</LI>
<LI><em>Cc</em>: <A HREF="mailto:eli%2B@cs.cmu.edu">eli+@cs.cmu.edu</A></LI>
<LI><em>In-Reply-To</em>: &lt;+cmu.andrew.internet.cypherpunks+IlYDbnW00UfAI10=1K@andrew.cmu.edu&gt;</LI>
<LI><em>Organization</em>: Dr. Beddoes' Pneumatic Institute</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@toad.com">owner-cypherpunks@toad.com</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
In article &lt;+cmu.andrew.internet.cypherpunks+IlYDbnW00UfAI10=1K@andrew.cmu.edu&gt; Raph writes:
&gt;   Now for the mathematical model. Signatures can bind keys to e-mail
&gt;addresses, or act as assertions that the signed public key is trusted to
&gt;transitively sign other keys. Let's assume that each signature has a
&gt;certain probability p of being good, and a 1-p probability of being
&gt;bogus, and that all probabilities are independent. These are probably
&gt;bad assumptions in the real world, but that's the difference between
&gt;theory and practice.

I'm not happy with the independence assumption.  Let's say I create a
keypair, put "president@whitehouse.gov" in the name field, and try to
get people to sign it as valid.  (I don't know what you're asserting
when you sign a key, but I'd say you're at least binding the key to
the name and address attached to it.)

Each signature has an /a priori/ probability p of correctly indicating
validity, but these probilities are not independent at all: this key
isn't valid, period.  If one certifying signature is incorrect, all
others on the same key must be, and vice versa -- about as correlated
as they come.

&gt;   Now we can actually evaluate the probability of a given key being
&gt;good. Consider a Monte Carlo process in which each edge in the graph is
&gt;present with probability 1-p. For each run, we determine whether the
&gt;recipient's public key (actually the binding between public key and
&gt;recipient's e-mail address) is reachable from our trust root.
&gt;The probability over a large number of runs is (given our assumptions) the 
&gt;probability of the key being good.

There are two separate problems:
1) key reachability -- do I think I can trust this key?
2) key validity -- is this key really okay?

The graph reachability problem asks whether there exists a valid path.  
This is what you want for the key reachability problem.  But the key
validity problem should be asking whether all paths are valid; a
single invalid path to me (posing as the Prez, remember) means that I
get to read your mail to Bill (big deal, eh?).  So you'd need to turn
it around, and ask whether there exists an invalid path.  From your
use of "1-p" for the probability, you may have been thinking along
these lines already.

So an edge (u,v) in G indicates that u trusts v.  With probability 
q = 1-p, Mallet is able to fool v.  That is, Pr[(u,v) in G'] = q.
Then we ask whether there's a path from s to t in G' -- that is, from
you to the key you pulled off the net.  If one exists, you lose.  

To limit transitivity, constrain the path length.  This limits key
reachability too, but I think we agree that it's essential in the real
world.  (It should also make the math simpler!)  The model generalizes
to non-binary conceptions of trust, but I don't think these can
rehabilitate transitivity.  Hmm, there are some possible approaches,
though.

These probabilities q are somewhat dependent: if I'm smart about whom
I trust, all of the q_(me, v) values will be somewhat lower, and vice
versa.  I think they're mostly independent, though.  But this is an
improvised model; poke holes in it.

-- 
. Eli Brandt                                        usual disclaimers .
. eli+@cs.cmu.edu                                  PGP key on request .
. violation of 18 U.S.C. 1462:                                  "fuck".

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00626.html">Re: Free demo disk of "distorted number" crypto</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00628.html">Re: Free demo disk of "distorted number" crypto</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00585.html">Re: Transitive trust and MLM</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00636.html">Re: Transitive trust and MLM</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00597"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00597"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
