<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: Binding cryptography &#45; a fraud&#45;detectible alternative to -->
<!--X-From-R13: Oqnz Pnpx <nonNqpf.rk.np.hx> -->
<!--X-Date: Mon, 14 Oct 1996 01:24:36 &#45;0700 (PDT) -->
<!--X-Message-Id: 199610140540.GAA00133@server.test.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 199610131050.LAA28296@mail.rijnhaave.nl -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: Binding cryptography - a fraud-detectible alternative to</TITLE>
<LINK REV="made" HREF="mailto:aba@dcs.ex.ac.uk">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg01056.html">Date Prev</A>][<A HREF="msg01059.html">Date Next</A>][<A HREF="msg01034.html">Thread Prev</A>][<A HREF="msg01060.html">Thread Next</A>][<A HREF="index.html#01057">Date Index</A>][<A HREF="threads.html#01057">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: Binding cryptography - a fraud-detectible alternative to</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:everheul@mail.rijnhaave.nl">everheul@mail.rijnhaave.nl</A></LI>
<LI><em>Subject</em>: Re: Binding cryptography - a fraud-detectible alternative to</LI>
<LI><em>From</em>: Adam Back &lt;<A HREF="mailto:aba@dcs.ex.ac.uk">aba@dcs.ex.ac.uk</A>&gt;</LI>
<LI><em>Date</em>: Mon, 14 Oct 1996 06:40:10 +0100</LI>
<LI><em>CC</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A>, <A HREF="mailto:henkvt@win.tue.nl">henkvt@win.tue.nl</A>, <A HREF="mailto:E.J.Koops@kub.nl">E.J.Koops@kub.nl</A>, <A HREF="mailto:everheul@NGI.NL">everheul@NGI.NL</A></LI>
<LI><em>In-reply-to</em>: &lt;<A HREF="msg01034.html">199610131050.LAA28296@mail.rijnhaave.nl</A>&gt;(everheul@mail.rijnhaave.nl)</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@toad.com">owner-cypherpunks@toad.com</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

Eric Verheul &lt;everheul@rijnhaave.nl&gt; writes:
&gt; To  explain the backround of "binding cryptography" once more; with
&gt; respect to (interoperable, worldwide) security in the information
&gt; society socities/governments have to achieve two tasks: 1. 
&gt; stimulating the establishment of a security structure that protects
&gt; their citizens, but which does not aid criminals. 

I think market forces should cope with this just fine, without
governments.  The government `stimulation' imposed by the US
government on clipper/encryption export has cost the US software
industry billions of $ in lost trade, and the US tax payer many more
millions paying for the failed secret NSA development of clipper I.

I don't see anyone calling for the `government stimulation', quite the
opposite; the US software industry is calling for removal of export
controls.  The US software industry has been extremely uncooperative
with Clipper I, II &amp; III.  The US public out right rejected clipper I.
Then Clinton passed it as a government standard by presidential decree
anyway.  The USG achieved some small appearance of cooperation from a
few companies they black-mailed and bribed into signing on for clipper
IV.

The USG managed to persuade the OECD to discuss key escrow, and now we
see that the USG says that it must pursue key escrow because of the
pressure from the OECD.  This is simply manipulation, and deception.

&gt; We believe that "binding cryptography" is flexible enough to achieve
&gt; this: a liberal crypto policy might use no Trusted Retrieval Parties
&gt; at all, while a very non-liberal country might want one (government
&gt; controlled) TRP, a compliance check on all network traffic and a ban
&gt; on other crypto.

I agree, binding cryptography is an important new technology for
implementing conditional third party access to keys.  Have you applied
for patents?

&gt; With binding cryptography the issue on a crypto policy becomes
&gt; non-technical and politically debatable: which features does a
&gt; country want and what implementation?

Cypherpunks vote is for none.  We vote that the civilized countries
set a good example to China and Singapore etc, by having no key
escrow, TTPs, TRPs etc.

&gt; The concept behind the third-party checking is that no "law-abiding"
&gt; citizen should have any problem that abuse - and only that - of a
&gt; *voluntary* system can be "seen" by many parties. 

If its voluntary then "abuse" is not abuse, it is just not opting to
use the voluntary system.  Where is the problem?

The problem is that you appear to want to make those who do
voluntarily use the escrow systems non-interoperable with those who
don't.  (The USG wants this also, they can coerce big business into
offering escrow software only).

&gt; If and *how* checking is done, is a matter of each society. The same
&gt; concept holds for many things in life and is well accepted. For
&gt; instance that is why cars have registration plates: if a car drives
&gt; through after an accident on a *public* road, then by-standers
&gt; (third parties) can observe that. I for one don't the information
&gt; society to be the wild west, where anything goes.

I do.  I want the information society to be free.  I want free speech.
I can not do a hit and run with words.

If some group of prudish people do not want to hear free speech, they
can hide in enclaves, pay for a censored USENET feed, etc.

&gt; Adam Back[SMTP:aba@dcs.ex.ac.uk] wrote:
&gt; &gt; As your paper describes, your system allows anyone to check the
&gt; &gt; correctness of the escrowed session key.  Have you considered
&gt; &gt; modifying it so that the only person who can check is the owner of a
&gt; &gt; designated private key of a public/private key pair?  This would
&gt; &gt; allow say for the TTP to check correctness, and not the TRP, nor the
&gt; &gt; public. I'm not sure of the usefulness of this, but it allows you to
&gt; &gt; select from the full spectrum according to requirements:
&gt; &gt;
&gt; &gt; a) no one can check, PGP second recipient (Carl Ellison, Bill
&gt; &gt; Stewart) 
&gt; &gt;
&gt; &gt; b) recipient only can check (my suggestion) 
&gt; &gt; 
&gt; &gt; c) holder(s) of designated keys can check 
&gt; &gt; 
&gt; &gt; d) anyone can check (your proposal)
&gt; &gt;
&gt; &gt; c) should be easy to acheive: restrict d) by having the sender
&gt; &gt; encrypt the escrowed session key a second time to this public key.
&gt; 
&gt; Point a) can be circumvented too easily.

If the system is voluntary, circumventing it is opting not to make use
of the voluntary key escrow.  This is by definition not a crime.

&gt; How do you envision point b? Sending all keys (or a selection) to
&gt; the recipient for checking is: impractical &amp; dangerous (you want the
&gt; distance between the actual communication and the guy that can
&gt; decypher as large as possible). 

I don't undestand your point.  You give away less by letting the
recipient check than you do by letting the government (point c), or
anyone (point d) check.

This is how I envisioned it working, RSA and IDEA encryption:

parties:

Alice:  Alices public key = PK_a, Alice's secret key = SK_a
Bob:    PK_b, SK_b
Government:    PK_g, SK_g

Alice is sending Bob the message M. 

E_b = RSA_encrypt( PK_b, left-pad_b || session-key || right-pad_b )
E_g = RSA_encrypt( PK_g, left-pad_g || session-key || right-pad_g )
encrypted-data = IDEA_encrypt( session-key, left-pad_g || right-pad_g || M )

Alice sends Bob:

C = E_b || E_g || encrypted-data

Bob can decrypt.  He can check that the government can decrypt by
repeating:

E_g = RSA_encrypt( PK_g, left-pad_g || session-key || right-pad_g )

If Alice replaces the session key in E_g with garbage, then the data
is not GAKed.  Bob will be able to detect this.  The government will
not (at least not without trying to decrypt).

&gt; If you don't send keys, then abuse will only show up during a
&gt; warrant.  But that abuse will show up anyway.. So what is the use?

It's voluntary, if it turns out that you did not use key escrow during
a warant, then the keys weren't escrowed.  This is what you get with a
voluntary system, people don't have to use it.

If you choose to allow the person who you are corresponding with to
verify that you are escrowing your keys, that is your business.

If you choose to allow the government also to check (option c, or d)
then that also is your business.  The whole system is voluntary.  I
don't see how you can arrange it any other way, and still claim that
it is a `voluntary' system.

&gt; Point c is a nice suggestion. Although I for one have no problem
&gt; that anyone can see that I comply with the rules (..unless of course
&gt; it is a non-voluntary system etc..).

The TTP might want to be the only checker.  With c), the TRP itself can not
check compliance.  The TRP has no information until the TTP decrypts, and
hands it the key for recovery.  This means the TTP does not have to trust
the TRP not to decrypt packets, without cooperation from the TTP.

user calculates:

E_trp = ElGamal_encrypt( PK_trp, session-key )

and sends:

E_ttp = ElGamal_encrypt( PK_ttp, random-pad || E_trp )
E_user = ElGamal_encrypt( PK_user, session-key )

(random-pad to avoid any further binding checks)

now TTP can check, by decrypting E_ttp to get E_trp, and using the
normal binding check that E_trp and E_user are encryptions of the same
session key.  The TTP sends TRP E_trp, and TRP can decrypts it, if the
request satisfies it's policies.

If the TTP further wishes that the TRP does not see the session key,
even when the TTP has cooperated with the TRP to get the key, you
could arrange key splitting:

user calculates:

session-key = session-A XOR session-B
E_trpa = ElGamal_encrypt( PK_trp, session-A )

user sends:

E_ttpa = ElGamal_encrypt( PK_ttp, random-pad || E_trpa )
E_ttpb = ElGamal_encrypt( PK_ttp, session-B )
E_usera = ElGamal_encrypt( PK_user, session-A )
E_userb = ElGamal_encrypt( PK_user, session-B )

recipient calculates:

session-A = ElGamal_decrypt( SK_usera, E_usera) 
session-B = ElGamal_decrypt( SK_userb, E_userb) 
session-key = session-A XOR session-B

TTP checks:

check = bind( E_usera, E_trpa ) AND bind( E_ttpb, E_userb )
session-A = ElGamal_decrypt( SK_ttp, E_ttpb) 

TRP at TTP's request:

session-B = ElGamal_decrypt( SK_trp, Etrp )

Then TTP calculates:

session-key = session-A XOR session-B

Adam
--
#!/bin/perl -sp0777i&lt;X+d*lMLa^*lN%0]dsXx++lMlN/dsM0&lt;j]dsj
$/=unpack('H*',$_);$_=`echo 16dio\U$k"SK$/SM$n\EsN0p[lN*1
lK[d2%Sa2/d0$^Ixp"|dc`;s/\W//g;$_=pack('H*',/((..)*)$/)

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="01034" HREF="msg01034.html">RE: RE: Binding cryptography - a fraud-detectible alternative to</A></STRONG>
<UL><LI><EM>From:</EM> everheul@mail.rijnhaave.nl</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg01056.html">Re: Blinded Identities [was Re: exporting signatures only/CAPI]</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg01059.html">Re: "Drift net fishing," GAK, FBI, and NSA</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg01034.html">RE: RE: Binding cryptography - a fraud-detectible alternative to</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg01060.html">RE: RE: Binding cryptography - a fraud-detectible alternative to</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#01057"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#01057"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
