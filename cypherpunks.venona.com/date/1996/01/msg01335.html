<!-- MHonArc v2.4.3 -->
<!--X-Subject: Hack Java -->
<!--X-From-R13: Dvpu Enym <efnymNbfs.bet> -->
<!--X-Date: Thu, 25 Jan 1996 18:07:52 +0800 -->
<!--X-Message-Id: 9601231630.AA07540@sulphur.osf.org -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Hack Java</TITLE>
<LINK REV="made" HREF="mailto:rsalz@osf.org">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg01454.html">Date Prev</A>][<A HREF="msg01471.html">Date Next</A>][<A HREF="msg01354.html">Thread Prev</A>][<A HREF="msg01241.html">Thread Next</A>][<A HREF="index.html#01335">Date Index</A>][<A HREF="threads.html#01335">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Hack Java</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Subject</em>: Hack Java</LI>
<LI><em>From</em>: Rich Salz &lt;<A HREF="mailto:rsalz@osf.org">rsalz@osf.org</A>&gt;</LI>
<LI><em>Date</em>: Tue, 23 Jan 1996 11:30:01 -0500</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@toad.com">owner-cypherpunks@toad.com</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
This illustrates the difference between a language with no dangerous
constructs, and one where you must trust the implementation.
&gt;From some internal OSF email:
---------- Begin Forwarded Message ----------

class Data { // an object storing 16 bytes 
	byte word[16];
}


class Trick {
	Data data;
	long tricky_pointer;
	}


Now suppose, I fake a compiler (or I have a malicious compiler)
and I generate by hand malicious byte code such that
in the symbol tables, tricky_pointer and data have the same
offset.


Then if I have the code

	tricky_pointer = 10000;
	for (; tricky_pointer &lt; 50000 ;) {
		dumptofile(trick.data)
		tricky_pointer += 16;
	}

what I am doing with this code is that I am actually setting the data
object reference to point to address 10000, then I am core dumping the
contents of memory upto address 50000, 16 bytes at a time! The byte
code is completely legal, I have cheated with the field offsets so
that I can access to the same memory as two different types.

In order to detect that the byte code verifier must verify that
all the fields of an object do not overlap in their memory
layout. That's what has to be checked.

----------- End Forwarded Message -----------


</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<UL><LI><STRONG>Follow-Ups</STRONG>:
<UL>
<LI><STRONG><A NAME="01241" HREF="msg01241.html">Re: Hack Java</A></STRONG>
<UL><LI><EM>From:</EM> gback@facility.cs.utah.edu</LI></UL></LI>
<LI><STRONG><A NAME="01243" HREF="msg01243.html">Re: Hack Java</A></STRONG>
<UL><LI><EM>From:</EM> Simon Spero &lt;ses@tipper.oit.unc.edu&gt;</LI></UL></LI>
<LI><STRONG><A NAME="01327" HREF="msg01327.html">Re: Hack Java</A></STRONG>
<UL><LI><EM>From:</EM> Matthew Sheppard &lt;Matthew.Sheppard@Comp.VUW.AC.NZ&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg01454.html">Re: Crippled Notes export encryption</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg01471.html">(FWD) UUNET Offers Web Security Services 01/22/96</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg01354.html">Re: Hack Java</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg01241.html">Re: Hack Java</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#01335"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#01335"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
