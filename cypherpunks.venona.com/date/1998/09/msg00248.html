<!-- MHonArc v2.4.3 -->
<!--X-Subject: Official comment -->
<!--X-From-R13: ovyy cnlar <ovyycNazby.pbz> -->
<!--X-Date: Thu, 10 Sep 1998 08:00:28 +0800 -->
<!--X-Message-Id: 35F7C9BB.7B5E@nmol.com -->
<!--X-Content-Type: multipart/mixed -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Official comment</TITLE>
<LINK REV="made" HREF="mailto:billp@nmol.com">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00269.html">Date Prev</A>][<A HREF="msg00252.html">Date Next</A>][<A HREF="msg00269.html">Thread Prev</A>][<A HREF="msg00252.html">Thread Next</A>][<A HREF="index.html#00248">Date Index</A>][<A HREF="threads.html#00248">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Official comment</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:aesfirstround@nist.gov">aesfirstround@nist.gov</A>, <A HREF="mailto:lb@qainfo.se">lb@qainfo.se</A></LI>
<LI><em>Subject</em>: Official comment</LI>
<LI><em>From</em>: bill payne &lt;<A HREF="mailto:billp@nmol.com">billp@nmol.com</A>&gt;</LI>
<LI><em>Date</em>: Thu, 10 Sep 1998 06:44:43 -0600</LI>
<LI><em>CC</em>: ted lewis &lt;<A HREF="mailto:lewis@nps.navy.mil">lewis@nps.navy.mil</A>&gt;,       masanori fushimi &lt;<A HREF="mailto:fushimi@misojiro.t.u%2Dtokyo.ac.jp">fushimi@misojiro.t.u-tokyo.ac.jp</A>&gt;, <A HREF="mailto:jy@jya.com">jy@jya.com</A>,       j orlin grabbe &lt;<A HREF="mailto:kalliste@aci.net">kalliste@aci.net</A>&gt;, <A HREF="mailto:vicepresident@whitehouse.gov">vicepresident@whitehouse.gov</A>,       <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A>, <A HREF="mailto:ukcrypto@maillist.ox.ac.uk">ukcrypto@maillist.ox.ac.uk</A>,       <A HREF="mailto:biham@cs.technion.ac.il">biham@cs.technion.ac.il</A>, <A HREF="mailto:even@cs.technion.ac.il">even@cs.technion.ac.il</A>, <A HREF="mailto:wpi@wpiran.org">wpi@wpiran.org</A>,       <A HREF="mailto:abd@CDT.ORG">abd@CDT.ORG</A>, <A HREF="mailto:merata@pearl.sums.ac.ir">merata@pearl.sums.ac.ir</A>, <A HREF="mailto:lawya@lucs%2D01.novell.leeds.ac.uk">lawya@lucs-01.novell.leeds.ac.uk</A>,       <A HREF="mailto:sjmz@hplb.hpl.hp.com">sjmz@hplb.hpl.hp.com</A>, <A HREF="mailto:senatorlott@lott.senate.gov">senatorlott@lott.senate.gov</A>,       <A HREF="mailto:senator_leahy@leahy.senate.gov">senator_leahy@leahy.senate.gov</A>, <A HREF="mailto:conrad_burns@burns.senate.gov">conrad_burns@burns.senate.gov</A>,       <A HREF="mailto:larry_craig@craig.senate.gov">larry_craig@craig.senate.gov</A>, <A HREF="mailto:senator@wyden.senate.gov">senator@wyden.senate.gov</A>,       <A HREF="mailto:dpcintrn@osd.pentagon.mil">dpcintrn@osd.pentagon.mil</A>, <A HREF="mailto:abumujahid@taliban.com">abumujahid@taliban.com</A></LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@Algebra.COM">owner-cypherpunks@Algebra.COM</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
<A  HREF="http://csrc.nist.gov/encryption/aes/aes_home.htm#comments">http://csrc.nist.gov/encryption/aes/aes_home.htm#comments</A>

  OFFICIAL Comments - Anyone may provide NIST with OFFICIAL public    
comments on the AES candidate algorithms. NOTE  THAT ALL COMMENTS  
RECEIVED SHALL BE MADE PART OF THE PUBLIC RECORD. A comment may be    
submitted by sending an e-mail message to AESFirstRound@nist.gov. 

OFFICIAL Comment

<A  HREF="http://www.aci.net/kalliste/bw1.htm">http://www.aci.net/kalliste/bw1.htm</A>

to appear at <A  HREF="http://zolatimes.com/">http://zolatimes.com/</A>
</PRE>
<ADDRESS>Title: <STRONG>Black and White Test of Cryptographic Algorithms</STRONG></ADDRESS>
<TABLE><TR><TD BGCOLOR="white" STYLE="background-color: white; ">




<h2 align=center>Black and White Test of Cryptographic Algorithms</h2>
<h3 align=center><i>by William H. Payne</i></h3>
<center><table border=0 width=80%><tr><td>
<p>
<hr>
<b>
  The purpose of this article is to explain the underlying principles
  of cryptography by examples, and to show some criteria that should be
  met by cryptographic algorithms before they are seriously considered
  for adoption.
</b>
<hr>
<p>
Cryptography is the art or science of scrambling plaintext into ciphertext with a key
so that it cannot be read by anyone who does not possess the key.
<p>
Digital information is stored in the form of 1s and 0s, called BINARY.
<p>
<h3 align=center>Binary Numbers</h3>
<p>
Let’s count from DECIMAL 0 to 15 in BINARY by adding 1 to the previous number.
<p>
<center>
<table border=2 cellpadding=2>
<tr>
<td><b>decimal:</b></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>2</center></td>
<td><center>3</center></td>
<td><center>4</center></td>
<td><center>5</center></td>
<td><center>6</center></td>
<td><center>7</center></td>
<td><center>8</center></td>
<td><center>9</center></td>
<td><center>10</center></td>
<td><center>11</center></td>
<td><center>12</center></td>
<td><center>13</center></td>
<td><center>14</center></td>
<td><center>15</center></td>
</tr><tr>
<td><b>binary:</b></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>10</center></td>
<td><center>11</center></td>
<td><center>100</center></td>
<td><center>101</center></td>
<td><center>110</center></td>
<td><center>111</center></td>
<td><center>1000</center></td>
<td><center>1001</center></td>
<td><center>1010</center></td>
<td><center>1011</center></td>
<td><center>1100</center></td>
<td><center>1101</center></td>
<td><center>1110</center></td>
<td><center>1111</center></td>
</tr></table></center>
<p>
Notice that first we start with a single number position, which can be 0 or 1 in BINARY.  This
number position is a <i>bit</i>.  Call this first bit b<sub>0</sub>.
Notice that b<sub>0</sub> is either 0 or 1.  That is, b<sub>0</sub> = 0 or b<sub>0</sub> = 1.
<p>
To get to DECIMAL 2, we have to introduce a second BINARY bit--call it b<sub>1</sub>.  
We have b<sub>1</sub>b<sub>0</sub> = 10.  Next, for DECIMAL 3, we have BINARY b<sub>1</sub>b<sub>0</sub> = 11.
<p>
<center>
<table border=2 cellpadding=2>
<tr>
<td><b>binary:</b></td>
<td><center>0</center></td>
<td><center>1</center></td>
<td><center>10</center></td>
<td><center>11</center></td>
<td><center>100</center></td>
<td><center>101</center></td>
<td><center>110</center></td>
<td><center>111</center></td>
<td><center>1000</center></td>
<td><center>1001</center></td>
<td><center>1010</center></td>
<td><center>1011</center></td>
<td><center>1100</center></td>
<td><center>1101</center></td>
<td><center>1110</center></td>
<td><center>1111</center></td>
</tr><tr>
<td><b>numbered bits:</b></td>
<td><center>b<sub>0</sub></center></td>
<td><center>b<sub>0</sub></center></td>
<td><center>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
<td><center>b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub></center></td>
</tr></table></center>

<p>
Notice that the bit subscript represents a power of 2.  That is, b<sub>0</sub> really
means
<p>
b<sub><b>0</b></sub>*2^<b>0</b>,
<p>
where * is multiplication, and ^ exponentiation (for example, 2^0 = 1, 2^1 = 2, 2^2 = 4, 2^3 = 8).
The subscript on b is the same as the power on 2.  
<p>
If we had b<sub>26</sub>, we would know its meaning was b<sub><b>26</b></sub>*2^<b>26</b>.
If b<sub>26</sub> = 0, then this value is 0.  If b<sub>26</sub> = 1, then
this value is 2^26.
<p>
Now look at "1111" (which in BINARY is equal to DECIMAL 15).  In this
case, b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> = 1111.  The
right-most BIT (b<sub>0</sub>) is the <i>least</i>-significant bit, because
it corresponds to the lowest power of 2.
<p>
<h3 align=center>Converting Binary Numbers to Decimal Numbers</h3>
<p>
To convert a BINARY number ...b<sub>3</sub>b<sub>2</sub>b<sub>1</sub>b<sub>0</sub> to
a DECIMAL number Y, we simply write
<p>
<blockquote>
        Y =  b<sub>0</sub> + b<sub>1</sub> * 2 + b<sub>2</sub> * 2^2 + b<sub>3</sub> * 2^3 + ...
</blockquote>
<p>
The bits b<sub>0</sub>, b<sub>1</sub>, b<sub>2</sub>, b<sub>3</sub> are limited to the values 0 and 1 ONLY.
<p>
Performing the exponentiation of powers of 2 and reversing the bits gives
<p>
<blockquote>
        Y =  . . . + b<sub>3</sub> * 8  +  b<sub>2</sub> * 4 + b<sub>1</sub> * 2 +  b<sub>0</sub> .  
</blockquote>
<p>
Most of us were brought-up to understand that  the most significant digits are to the LEFT of the previous 
digit.
<p>
For sake of economy of writing and easy conversion, binary numbers are frequently represented
in base 16, or HEXADECIMAL, abbreviated HEX.
<p>
<h3 align=center>Hexadecimal Numbers</h3>
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Binary<br>weights</td><td>HEX</td><td>DECIMAL</td></tr>
<tr><td align=right>8 4 2 1</td><td></td><td></td></tr>
<tr><td align=right>      0</td><td align=right>    0</td><td align=right>  0</td></tr>
<tr><td align=right>      1</td><td align=right>    1</td><td align=right>  1</td></tr>
<tr><td align=right>    1 0</td><td align=right>    2</td><td align=right>  2</td></tr>
<tr><td align=right>    1 1</td><td align=right>    3</td><td align=right>  3</td></tr>
<tr><td align=right>  1 0 0</td><td align=right>    4</td><td align=right>  4</td></tr>
<tr><td align=right>  1 0 1</td><td align=right>    5</td><td align=right>  5</td></tr>
<tr><td align=right>  1 1 0</td><td align=right>    6</td><td align=right>  6</td></tr>
<tr><td align=right>  1 1 1</td><td align=right>    7</td><td align=right>  7</td></tr>
<tr><td align=right>1 0 0 0</td><td align=right>    8</td><td align=right>  8</td></tr>
<tr><td align=right>1 0 0 1</td><td align=right>    9</td><td align=right>  9</td></tr>
<tr><td align=right>1 0 1 0</td><td align=right>    A</td><td align=right> 10</td></tr>
<tr><td align=right>1 0 1 1</td><td align=right>    B</td><td align=right> 11</td></tr>
<tr><td align=right>1 1 0 0</td><td align=right>    C</td><td align=right> 12</td></tr>
<tr><td align=right>1 1 0 1</td><td align=right>    D</td><td align=right> 13</td></tr>
<tr><td align=right>1 1 1 0</td><td align=right>    E</td><td align=right> 14</td></tr>
<tr><td align=right>1 1 1 1</td><td align=right>    F</td><td align=right> 15</td></tr>
</table></center>
<p>
Conversion from binary to hexadecimal or hexadecimal to binary is easy if you remember
<p>
1010 is A  <br>
1100 is C  <br>
1110 is E
<p>
B is one greater than A, 1011.   D is one greater than C, 1101.  And F is one greater than E, 1111.
<p>
<h3 align=center>Computer Memory</h3>
<p>
Computer memory is frequently organized as BYTEs which are eight bits.
<p>
Since one hexadecimal digit represents 4 bits, it takes two hexadecimal digits to represent one byte.
<p>
There are 2^8 = 256 different binary values that can be represented in
a byte.  These 256 values (written in HEX for brevity) are:

<p>
<pre>
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F
30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F
40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F
50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F
60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F
70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F
80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
99 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F
A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF
B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF
C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF
D0 D1 D2 D3 D4 D5 D6 D7 D8 D9 DA DB DC DD DE DF
E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF
FF F1 F2 F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</pre>
<p>
<h3 align=center>Representing Language on a Computer</h3>
<p>
The problem of how to represent characters in a computer has been solved several ways.  One
way is the American Standard Code of Information Interchange (ASCII).
<p>
ASCII represents characters as 7 bits.
<p>
Here is table modified from a web site
(<a href="http://members.tripod.com/~plangford/index.html">
http://members.tripod.com/~plangford/index.html</a>).
<p>
<pre>
 Hex Char Description             Hex Char   Hex Char   Hex Char
----------------------            --------- ---------- ----------
  00  NUL (null)                   20         40  @      60    `
  01  SOH (start of heading)       21  !      41  A      61    a    
  02  STX (start of text)          22  "      42  B      62    b    
  03  ETX (end of text)            23  #      43  C      63    c    
  04  EOT (end of transmission)    24  $      44  D      64    d    
  05  ENQ (enquiry)                25  %      45  E      65    e    
  06  ACK (acknowledge)            26  &      46  F      66    f    
  07  BEL (bell)                   27  '      47  G      67    g    
  08   BS (backspace)              28  (      48  H      68    h    
  09  TAB (horizontal tab)         29  )      49  I      69    i    
  0A   LF (line feed, new line)    2A  *      4A  J      6A    j    
  0B   VT (vertical tab)           2B  +      4B  K      6B    k    
  0C   FF (form feed, new page)    2C  ,      4C  L      6C    l    
  0D   CR (carriage return)        2D  -      4D  M      6D    m    
  0E   SO (shift out)              2E  .      4E  N      6E    n    
  0F   SI (shift in)               2F  /      4F  O      6F    o    
  10  DLE (data link escape)       30  0      50  P      70    p    
  11  DC1 (device control 1)       31  1      51  Q      71    q    
  12  DC2 (device control 2)       32  2      52  R      72    r    
  13  DC3 (device control 3)       33  3      53  S      73    s    
  14  DC4 (device control 4)       34  4      54  T      74    t    
  15  NAK (negative acknowledge)   35  5      55  U      75    u    
  16  SYN (synchronous idle)       36  6      56  V      76    v    
  17  ETB (end of trans. block)    37  7      57  W      77    w    
  18  CAN (cancel)                 38  8      58  X      78    x    
  19   EM (end of medium)          39  9      59  Y      79    y    
  1A  SUB (substitute)             3A  :      5A  Z      7A    z    
  1B  ESC (escape)                 3B  ;      5B  [      7B    {    
  1C   FS (file separator)         3C  <      5C  \      7C    |    
  1D   GS (group separator)        3D  =      5D  ]      7D    }    
  1E   RS (record separator)       3E  >      5E  ^      7E    ~    
  1F   US (unit separator)         3F  ?      5F  _      7F  DEL
</pre>
<p>
Now let us take two different one-word messages we might wish to cipher: "black" and "white".  We
can use the preceding table to find the ASCII codes for the characters in "black" and "white".
<p>                  
<center>
<table border=2 cellpadding=2>
<tr><td>message</td><td><center>character</center></td><td><center>ASCII (Hex)</center></td><td><center>Binary</center></td></tr>
<tr><td>Message 1</td><td><center>black</center></td><td><center>62 6C 61 63 6B</center></td><td><center>0110 0010 0110 1100 0110 0001 0110 0011 0110 1011</center></td></tr>
<tr><td>Message 2</td><td><center>white</center></td><td><center>77 68 69 74 65</center></td><td><center>0111 0111 0110 1000 0110 1001 0111 0100 0110 0101</center></td></tr>
</table></center>
<p>
But before doing this, we must understand the general "cipher problem."
<p>
<h3 align=center>The Cipher Problem</h3>
<p>
We have three elements in the encryption process:
<blockquote>
<p>
        1.  The plaintext message <br>
        2.  The key               <br>
        3.  The ciphertext
</blockquote><p>
Let’s start REAL SIMPLE.  Let's consider a situation where the plaintext
message, the key, and the ciphertext <i>are all the same length</i>.  To
make it even simpler, let's make <i><b>each one only one bit long</b></i>.  So the key
can be one of two possibilities (0 or 1), and so can the plaintext and
the ciphertext.  So, in all, there are 2*2*2 = 8 total possible encipherment
circumstances.
<p>
Let’s enumerate ALL 8 POSSIBILITIES.
<p>
<center>
<table border=2 cellpaddingg=2>
<tr><td colspan=4><center><b>Possibilities Table</b></td></tr>
<tr><td>Possibility</td><td>Key</td><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td><b>1</b></td><td>0</td><td>0</td><td>0</td></tr>
<tr><td><b>2</b></td><td>0</td><td>0</td><td>1</td></tr>
<tr><td><b>3</b></td><td>0</td><td>1</td><td>0</td></tr>
<tr><td><b>4</b></td><td>0</td><td>1</td><td>1</td></tr>
<tr><td><b>5</b></td><td>1</td><td>0</td><td>0</td></tr>
<tr><td><b>6</b></td><td>1</td><td>0</td><td>1</td></tr>
<tr><td><b>7</b></td><td>1</td><td>1</td><td>0</td></tr>
<tr><td><b>8</b></td><td>1</td><td>1</td><td>1</td></tr>
</table></center>
<p>
That’s it!  There are no more possibilities than these 8.  What does this
mean for the encryption process--the "algorithm"?
<p>
An ALGORITHM is a deterministic processes that accepts inputs and transforms them into outputs.
<p>
"Deterministic" is important in that the same inputs ALWAYS produce the same output.
<p>
Consider ANY algorithm which takes as its inputs the key values of 0 or 1 and the plaintext message
values of 0 or 1.
<p>
ANY algorithm can only produce one of the ciphertext outputs seen above.  Image the following
hypothetical but REAL SIMPLE algorithm:
<blockquote>
<p>
<b>Hypothetical Algorithm</b>:  Find the value of the Key in column 2 of the Possibilities Table
and the Plaintext message in column 3; then chose as the Ciphertext output whatever number is found
in column 4 of that row.
</blockquote>
<p>
But there, of course, is a catch with a valid CRYPTOGRAPHIC ALGORITHM.  
<p>
Given the Key and the Ciphertext, one must be able to get back the Plaintext!  
<p>
A  cryptographic algorithmic should have an INVERSE.
<p>
So a cryptographic algorithm could not produce ALL of the eight combinations seen above for the
reason that it is impossible to invert some of the possibilities.  For example, some of the mappings
are incompatible from an inverse standpoint, because same values of the key and ciphertext
can lead to two different values of the plaintext.  Notice how the following pairs of possibilities
conflict: 1 and 3; 2 and 4; 5 and 7; 6 and 8.
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Possibility</td><td>Key</td><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td><b>1</b></td><td>0</td><td>0</td><td>0</td></tr>
<tr><td><b>3</b></td><td>0</td><td>1</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td><b>2</b></td><td>0</td><td>0</td><td>1</td></tr>
<tr><td><b>4</b></td><td>0</td><td>1</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td><b>5</b></td><td>1</td><td>0</td><td>0</td></tr>
<tr><td><b>7</b></td><td>1</td><td>1</td><td>0</td></tr>
<tr><td></td><td></td><td></td><td></td></tr>
<tr><td><b>6</b></td><td>1</td><td>0</td><td>1</td></tr>
<tr><td><b>8</b></td><td>1</td><td>1</td><td>1</td></tr>
</table></center>
<p>
But there two different cryptographic algorithms that could be made from the
Possibilities Table, both of which have inverses:
<p>
<center>
<table border=2 cellpaddingg=2>
<tr><td colspan=4><center><b>Cryptographic Algorithm 1</b></td></tr>
<tr><td>Possibility</td><td>Key</td><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td><b>1</b></td><td>0</td><td>0</td><td>0</td></tr>
<tr><td><b>4</b></td><td>0</td><td>1</td><td>1</td></tr>
<tr><td><b>6</b></td><td>1</td><td>0</td><td>1</td></tr>
<tr><td><b>7</b></td><td>1</td><td>1</td><td>0</td></tr>
</table></center>
<p>
<center>
<table border=2 cellpaddingg=2>
<tr><td colspan=4><center><b>Cryptographic Algorithm 2</b></td></tr>
<tr><td>Possibility</td><td>Key</td><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td><b>2</b></td><td>0</td><td>0</td><td>1</td></tr>
<tr><td><b>3</b></td><td>0</td><td>1</td><td>0</td></tr>
<tr><td><b>5</b></td><td>1</td><td>0</td><td>0</td></tr>
<tr><td><b>8</b></td><td>1</td><td>1</td><td>1</td></tr>
</table></center>
<p>
<p>
Of course, the output of Algorithm 2 is merely the same as the output of Algorithm 1,
with 0s and 1s switched.  (This is called a logical NOT operation.)
<p>
<h3 align=center>Logic and Its Electronic Representation</h3>
<p>
Logic,  sometimes called
<a href="http://www-stall.rz.fht-esslingen.de/studentisches/Computer_Geschichte/grp2/boole.html">
Boolean</a> logic when it is dealing with 0s and 1s, has several elementary rules.  
<p>
In computers, TRUE is usually represented by a 1.  FALSE is represented by a 0.
<p>
Electrically a 1 is usually, but not always, represented by a HIGH VOLTAGE.  A zero by a 
LOW VOLTAGE.
<p>
The three basic operations in logic are NOT, AND, and OR:
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Logical Operation</td><td colspan=2><center>Input(s)</td><td>Output</td></tr>
<tr><td>NOT</td><td>0</td><td></td> <td>1</td></tr>
<tr><td>   </td><td>1</td><td></td> <td>0</td></tr>
<tr><td>   </td><td> </td><td></td> <td> </td></tr>
<tr><td>AND</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>   </td><td>0</td><td>1</td><td>0</td></tr>
<tr><td>   </td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>   </td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>   </td><td> </td><td></td> <td> </td></tr>
<tr><td>OR </td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>   </td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>   </td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>   </td><td>1</td><td>1</td><td>1</td></tr>
</table></center>
<p>
A derivative operation called an EXCLUSIVE-OR, abbreviated <b>XOR</b>, is defined as follows:
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Logical Operation</td><td colspan=2><center>Input(s)</td><td>Output</td></tr>
<tr><td>XOR</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>   </td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>   </td><td>1</td><td>0</td><td>1</td></tr>
<tr><td>   </td><td>1</td><td>1</td><td>0</td></tr>
</table></center>
<p>
<b>In XOR, if the two input bits have the the same value, they sum to 0.  If they have
different values, they sum to 1.</b>
<p>
Now look back at Cryptographic Algorithm 1.  It is, in fact,
the exclusive-or (XOR) of the key and plaintext.
<p>
<blockquote>
<b>Algorithm 1</b>: Ciphertext Output = Key XOR Plaintext.
</blockquote>
<p>
Cryptographic Algorithm 2, meanwhile, is just the NOT of Algorithm 1.
<p>
<blockquote>
<b>Algorithm 2</b>: Ciphertext Output = NOT (Key XOR Plaintext).
</blockquote>
<p>
The REALLY IMPORTANT property of the <b>XOR</b> is THAT IT HAS AN INVERSE.
<p>
By contrast, logical AND does not have an inverse for the reason that if the
Key and (Key AND Plaintext) are both 0, then the Plaintext itself is ambiguously
either 0 or 1.
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Logical Operation</td><td>Key Input</td><td>Plaintext Input</td><td>Key AND Plaintext</td><td> </td></tr>
<tr><td>AND</td><td>0</td><td>0</td><td>0</td><td>oops</td></tr>
<tr><td>   </td><td>0</td><td>1</td><td>0</td><td>oops</td></tr>
<tr><td>   </td><td>1</td><td>0</td><td>0</td><td> </td></tr>
<tr><td>   </td><td>1</td><td>1</td><td>1</td><td> </td></tr>
</table></center>
<p>
Likewise, logical OR does not have an inverse for the reason that if the
Key and (Key OR Plaintext) are both 1, then the Plaintext itself is ambiguously
either 0 or 1.
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Logical Operation</td><td>Key Input</td><td>Plaintext Input</td><td>Key OR Plaintext</td><td> </td></tr>
<tr><td>OR </td><td>0</td><td>0</td><td>0</td><td> </td></tr>
<tr><td>   </td><td>0</td><td>1</td><td>1</td><td> </td></tr>
<tr><td>   </td><td>1</td><td>0</td><td>1</td><td>oops</td></tr>
<tr><td>   </td><td>1</td><td>1</td><td>1</td><td>oops</td></tr>
</table></center>
<p>
So logical AND and OR don’t work well for a crypto algorithm, but the XOR does because it has 
an inverse.
<p>
<h3 align=center>How to Create Two Keys for Deniability</h3>
<p>
The XOR works even better from a legal standpoint.  Imagine the following
conversation:
<p>
<blockquote>
        <b>Ciphercop</b>:  We have the ciphertext 0 and we CAUGHT you with the key with a bit value of 1, so you sent a plaintext 1.<br>
        <b>Citizen</b>:  No I did not!  You PLANTED the key with bit value 1. The real key bit is a 0, and I sent 0 as the plaintext.
</blockquote>
<p>
Let’s generate a key for the REAL WORLD crypto messages "black" and "white",
<p>                  
<center>
<table border=2 cellpadding=2>
<tr><td>message</td><td><center>character</center></td><td><center>ASCII (Hex)</center></td><td><center>Binary</center></td></tr>
<tr><td>Message 1</td><td><center>black</center></td><td><center>62 6C 61 63 6B</center></td><td><center>0110 0010 0110 1100 0110 0001 0110 0011 0110 1011</center></td></tr>
<tr><td>Message 2</td><td><center>white</center></td><td><center>77 68 69 74 65</center></td><td><center>0111 0111 0110 1000 0110 1001 0111 0100 0110 0101</center></td></tr>
</table></center>
<p>
and see if we can produce a REAL EXAMPLE of a SECOND KEY.
<p>
Here’s a key, which we will call key 1:
<p>
<pre>
<b>key 1:</b> 1010 0101   1100 0011   1110 0111   1111 0000   0110 1001
</pre>
<p>
Key 1 doesn’t look too random.  Each group of four bits is followed by its
logical NOT (e.g. NOT(1010) = 0101, etc.).  Which leads to another lesson.
<p>
<blockquote><b>
        To claim that a sequence of 0s and 1s is <i>random</i> requires statistical testing.<br>
	Otherwise, the state of the sequence is UNKNOWN.
</b></blockquote>       
<p>
Here's another key, which we will call key 2:
<p>
<pre>
<b>key 2:</b> 1011 0000    1100 0100   1110 1111   1110 0111   0110 0111
</pre>
<p>
These two keys produce the <b>same ciphertext</b> for the two different
messages "black" and "white".
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>black</td><td>0110 0010    0110 1100   0110 0001   0110 0011   0110 1011</td></tr>
<tr><td>key 1</td><td>1010 0101    1100 0011   1110 0111   1111 0000   0110 1001</td></tr>
<tr><td>ciphertext (XOR)</td><td>1100 0111    1010 1100   1000 0110   1001 0011   0000 0010</td></tr>
</table></center>
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>white</td><td>0111 0111    0110 1000   0110 1001   0111 0100   0110 0101</td></tr>
<tr><td>key 2</td><td>1011 0000    1100 0100   1110 1111   1110 0111   0110 0111</td></tr>
<tr><td>ciphertext (XOR)</td><td>1100 0111    1010 1100   1000 0110   1001 0011   0000 0010</td></tr>
</table></center>
<p>
So when the ciphercops FALSELY accuse you of encrypting "black", you SCREAM
"Bull pucky!", and produce key 2 to show that you, IN FACT, encrypted "white".
Then sue the government--<i>pro se</i>, of course. (See <a href="http://jya.com/whpfiles.htm">http://jya.com/whpfiles.htm</a>.)
<p>
The recipe for producing the second key in this example is simple.  Take two plaintext messages of the
same length.  Encrypt one of them with an arbitrary key that yields a ciphertext of the
same length.  XOR the ciphertext with the second plaintext message.  The result is the
second key.  Store this one for plausible deniability.
<p>
So from the standpoint of plausible deniability it is BEST to have TWO KEYS
for any given encryption:
<p>
<blockquote>
        1. The REAL KEY  <br>
        2. The key you can CLAIM was the REAL KEY.  Just in case you get caught.
</blockquote>
<p>
<center>
<table border=2 valign=center>
<tr><td><center><b>"Have we gone beyond the bounds of reasonable dishonesty?"<br>
                --CIA memo</center></b></td></tr>
</table></center>                
<p>          
(The CIA quote is from <a href="http://www.thegrid.net/fern.canyon/weird/contents.htm">
<i>Weird History 101</i>, by  John Richard Stephens</a>, page 55.)
<p>
None of us want to get caught going beyond the bounds of reasonable dishonesty.
<p>
Thus far two criteria of a worth candidate for cryptographic algorithm have been established.
<p>
<table border=2>
<tr><td>
<h3>Criterion 1: The ciphertext is invertible with the help of a key back into the plaintext.</h3>
<h3>Criterion 2: There is ALWAYS a second key.  Just in case you get caught.</h3>
</td></tr></table>
<p>
<h3 align=center>Plaintext and Ciphertext Sizes</h3>
<p>
The plaintext and ciphertext should be the same size.
<p>
First, note that if the plaintext is <i>longer</i> than the ciphertext, then the
ciphertext is not invertible.  For example, let’s suppose that the plaintext
is two bits long and the ciphertext is one bit long.
<p>
<center>
<table border=2 cellpadding=2>
<tr><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td>0 0</td><td>0 or 1</td></tr>
<tr><td>0 1</td><td>1 or 0</td></tr>
<tr><td>1 0</td><td>oops</td></tr>
<tr><td>1 1</td><td>oops</td></tr>
</table></center>
<p>
After the first two ciphertext bits have been assigned to plaintext pairs,
the next two plaintext pairs (10,11) must conflict with this assignment. The
ciphertext thus correspondents to more than one plaintext possibility.
<p>
We run into problems for the reason that we cannot establish a one-to-one
correspondence between the plaintext and cipher text and, therefore, can’t
possibly have an inverse.
<p>
Second, if the plaintext is <i>shorter</i> than the ciphertext, then the
ciphertext can't be trusted.  It may include too much information.  For
example, let’s suppose that the plaintext is one bit long, the key is one
bit long, and the cipher text is two bits long.
<p>
<center>
<table border=2 cellpadding=2>
<tr><td colspan=3><center><b>Iran Cryptographic Algorithm</b></center></td></tr>
<tr><td>Key</td><td>Plaintext</td><td>Ciphertext</td></tr>
<tr><td>0  </td><td>0        </td><td>00        </td></tr>
<tr><td>0  </td><td>1        </td><td>10        </td></tr>
<tr><td>1  </td><td>0        </td><td>11        </td></tr>
<tr><td>1  </td><td>1        </td><td>01        </td></tr>
</table></center>
<p>
Not only is the above algorithm invertible, but now the crypto key has been sent
along with the ciphertext in the second bit position!
<p>
That is, the first bit in the ciphertext is is the value of (key XOR plaintext).
The second bit is the key itself.  So if you XOR the two ciphertext bits
with each other, you recover the plaintext bit.
<p>
You might ask who would be audacious enough to pull such  stunt.  The Great Satan,
of course.
<p>
For the story of how the National Security Agency (NSA) bugged the encryption
equipment that was sold by a Swiss company to 140 nations around the world, see
the following links:
<p><blockquote>
<a href="http://www.aci.net/kalliste/speccoll.htm">
http://www.aci.net/kalliste/speccoll.htm</a> <br>

<a href="http://caq.com/cryptogate">
http://caq.com/cryptogate</a> <br>

<a href="http://www.qainfo.se/~lb/crypto_ag.htm">
http://www.qainfo.se/~lb/crypto_ag.htm</a> <br>

<a href="http://jya.com/whpfiles.htm">
http://jya.com/whpfiles.htm</a>

</blockquote>
<p>
And the Great Satan got caught.  No plan B.  Or in crypto parlance, no second key.
<p>
So we have a third criterion for a cryptographic algorithm we might wish to adopt.
<p>
<table border=2>
<tr><td>
<h3>Criterion 3:  The length of the plaintext equals the length of the ciphertext.</h3>
</td></tr></table>
<p>
In simple terms, if more bits come out of a crypto algorithm than go in, WATCH OUT!
<p>
<h3 align=center>Otis Mukinfuss and the Advanced Encryption Standard</h3>
<p>
Bruce Hawkinson (<a href="mailto:BHAWKIN@sandia.gov">BHAWKIN@sandia.gov</a>)
WAS Sandia National Laboratories Lab News editor some years ago.
<p>
In one editorial, Hawkinson wrote that while we was traveling for Sandia, he
spent his motel time looking up strange names in the phone book.  One name
I recall mentioned was Steely Gray who was a government office furniture
salesman.
<p>
Hawkinson concluded his article by writing his all-time favorite name was
Otis Mukinfuss.
<p>
Hawkinson was no longer editor of Sandia’s Lab News shortly thereafter.
<p>
J. Orlin Grabbe has done an excellent job writing about cryptographic algorithms in
<a href="http://www.aci.net/kalliste/cryptnum.htm">
Cryptography and Number Theory for Digital Cash</a>.
<p>
One inescapable conclusion from Grabbe’s internet article is that from a layman’s
standpoint public key cryptography is an incomprehensible mess.  A Muckinfuss.
<p>
The National Institute of Standards and Technology (NIST) is holding a CONTEST to select
an <a href="http://www.nist.gov/aes">Advanced Encryption Standard</a> to replace the
current Data Encryption Standard (DES).
<p>
Click through the candidates to view some additional examples of Mukinfusses.
<p>
So another criterion has been established for a cryptographic algorithm to be considered
for adoption.
<p>
<table border=2>
<tr><td>
<h3>Criterion 4:  The crypto algorithm must be simple and CONVINCE  EVERYONE that it is
             ONLY PERFORMING ITS SIMPLE INTENDED FUNCTION.</h3>
</td></tr></table>
<p>
While we are at the NIST web site, the NIST Advanced Encryption Standard contest reminds
me of a the plot of a recent movie, <i>The Game</i>, starring Michael Douglas and Sean Penn:
<p>
<blockquote>
        The film is a thriller directed by David Fincher (Se7en). "The Game"
        is what begins when a high-powered businessman named Nicholas Van 
        Orton (Douglas) receives the birthday gift of a lifetime from his 
        brother he alienated years ago (Penn). What Nicholas gets is entry 
        into a mysterious new form of entertainment provided by C.R.S. 
        (Consumer Recreational Services) simply called "The Game." It 
        proves to be an all-consuming contest with only one rule: there are 
        no rules. By the time Van Orton realizes he is in, it is too late to get 
        out.  ...
        (See <a href="http://www.movietunes.com/soundtracks/1997/game/">
                http://www.movietunes.com/soundtracks/1997/game/</a>.)

</blockquote>
<p>
NIST does not appear to publish any criteria for winning the AES contest!
Look at <a href="http://www.nist.gov/public_affairs/confpage/980820.htm">
http://www.nist.gov/public_affairs/confpage/980820.htm</a> and decide for
yourself.
<p>
<h3 align=center>Perfect Cryptography</h3>
<p>
Here we have described a process of encrypting a plaintext by XORing it
with a key of the same length.  This encryption technique is called a
"one-time pad", or Vernam cipher.  Just as long as each key is only used once,
the encryption technique is perfectly secure.
<p>
The one-time pad described here satisfies all criteria mentioned so far:
<p>
<blockquote>
1. The ciphertext is invertible with the help of a key back into the plaintext.<br>
2. There is ALWAYS a second key.  Just in case you get caught. <br>
3. The length of the plaintext equals the length of the ciphertext. <br>
4. The crypto algorithm must be simple and CONVINCE EVERYONE that it is <br>
    ONLY PERFORMING ITS SIMPLE INTENDED FUNCTION.
</blockquote>
<p>
I  add
<p>
<table border=2 >
<tr><td>
<h3>Criterion 5:  The length of the key must equal the length of the plaintext.</h3>
</td></tr></table>
<p>
Extensive mathematics or complication fails Criterion 4.
<p>
Public key cryptograpy that uses the RSA algorithm MAY fail Criterion 1 if the 
message divides the product of the two prime numbers, p and q, used in the modulus.
<p>
Most crypto algorithms are designed so that the key cannot be recovered from a
plaintext-ciphertext pair.  Therefore, they fail Criterion 2.
<p>
Criterion 3 is much more difficult to ensure against.
<p>
<h3 align=center>Black and White Hats</h3>
<p>
American western movie producers used to aid their audiences in identification
of the heroes and villains.  The heroes wore white hats.  The villains, black hats.
<p>
US government agencies adopted the term ‘black hatter’ to describe an employee whose
job it is to break into THINGS. Or screw them up:
<a href="http://www.jya.com/whp1.htm">http://www.jya.com/whp1.htm</a>
<p>
A ‘white hatter’ is one who analyzes THINGS to make sure they cannot be broken into.
And they can’t be screwed up.
<p>
But the empirical fact is that the ‘black hatters’ can figure-out methods to transmit
the key on a covert channel, tell the ‘white hatters’ they did this.  And the ‘white
hatters’ can’t find out how they did it.
<p>                 
<h3 align=center>Algorithmic Processes</h3>
<p>
Suppose the key is five bits:
<p>
 1 0 1 0 1
<p>
Suppose the plaintext is six bits:
<p>
1 1 1 1 1 1
<p>
And the ciphertext is also six bits:
<p>
1 0 1 1 0 1
<p>
Ask the cryptographer give you a key which changes ONLY the sixth bit of the
ciphertext, as in the following:
<p>
1 0 1 1 0 0
<p>
You like the other 5 bits just fine.
<p>
If the cryptographer can’t, then you might look for another algorithm to adopt.
<p>
<h3 align=center>Conclusion</h3>
<p>
We have five criteria to judge the outcome of the NIST Advanced Encryption Standard contest.
<p>
If none of the algorithms pass the five tests, we will not be discouraged.
<p>
We know that Gilbert S. Vernam and Joseph O. Mauborgne  solved the crytptography problem in 1918,
when they created the one-time pad.  (See
<a href="http://test.team2it.com/rsa/q93.html">
"What is a One-Time Pad?"</a>.)
<p>
<p>
William H. Payne               <br>
P.O. Box 14838                 <br>
Albuquerque, New Mexico 87191  <br>
505-292-7037                   <br>
<a href="http://www.apcatalog.com/cgi-bin/AP?ISBN=0125475705&LOCATION=US&FORM=FORM2">
Embedded Controller Forth</a>. <br>
<a href="http://www-hto.usc.edu/software/seqaln/doc/html/gfsr.3.html">
Generalized Feedback Shift Registers</a> <br>          
<p>
Here are some links to some of my students:
<p>
<a href="http://www.friction-free-economy.com/">     
Ted Lewis (Friction-Free Economy)</a> <br>     
<a href="http://www.mhpcc.edu/general/john.html">     
John Sobolewski (HPCERC)</a> <br>     
<p>
<center>-30-</center>
</td></tr></table></center>


</TD></TR></TABLE>
<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00269.html">Error.</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00252.html">CJ Key Check</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00269.html">Error.</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00252.html">CJ Key Check</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00248"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00248"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
