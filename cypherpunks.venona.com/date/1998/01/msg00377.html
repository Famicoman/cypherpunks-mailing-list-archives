<!-- MHonArc v2.4.3 -->
<!--X-Subject: LUC Public Key Crypto... -->
<!--X-From-R13: Xvz Qubngr <enintrNffm.pbz> -->
<!--X-Date: Sun, 11 Jan 1998 09:26:35 +0800 -->
<!--X-Message-Id: 199801110150.TAA15260@einstein.ssz.com -->
<!--X-Content-Type: text -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>LUC Public Key Crypto...</TITLE>
<LINK REV="made" HREF="mailto:ravage@ssz.com">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00403.html">Date Prev</A>][<A HREF="msg00378.html">Date Next</A>][<A HREF="msg00375.html">Thread Prev</A>][<A HREF="msg00378.html">Thread Next</A>][<A HREF="index.html#00377">Date Index</A>][<A HREF="threads.html#00377">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>LUC Public Key Crypto...</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@ssz.com">cypherpunks@ssz.com</A> (Cypherpunks Distributed Remailer)</LI>
<LI><em>Subject</em>: LUC Public Key Crypto...</LI>
<LI><em>From</em>: Jim Choate &lt;<A HREF="mailto:ravage@ssz.com">ravage@ssz.com</A>&gt;</LI>
<LI><em>Date</em>: Sat, 10 Jan 1998 19:50:27 -0600 (CST)</LI>
<LI><em>Cc</em>: <A HREF="mailto:austin%2Dcpunks@ssz.com">austin-cpunks@ssz.com</A> (Austin Cypherpunks)</LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@Algebra.COM">owner-cypherpunks@Algebra.COM</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>

Hi,

In the process of doing some research on Gauss I stumbled across this...


    ____________________________________________________________________
   |                                                                    |
   |      Those who make peaceful revolution impossible will make       |
   |      violent revolution inevitable.                                |
   |                                                                    |
   |                                          John F. Kennedy           |
   |                                                                    |
   |                                                                    | 
   |            _____                             The Armadillo Group   |
   |         ,::////;::-.                           Austin, Tx. USA     |
   |        /:'///// ``::&gt;/|/                     <A  HREF="http://www.ssz.com/">http://www.ssz.com/</A>   |
   |      .',  ||||    `/( e\                                           |
   |  -====~~mm-'`-```-mm --'-                         Jim Choate       |
   |                                                 ravage@ssz.com     |
   |                                                  512-451-7087      |
   |____________________________________________________________________|


Forwarded message:

&gt;    Dr. Dobb's Web Site
&gt;    
&gt;                           LUC PUBLIC-KEY ENCRYPTION
&gt;                                        
&gt;    
&gt;    
&gt;    A secure alternative to RSA
&gt;    
&gt;    Peter Smith
&gt;    
&gt;    Peter has worked in the computer industry for 15 years as a
&gt;    programmer, analyst, and consultant and has served as deputy editor of
&gt;    Asian Computer Monthly. Peter's interest in number theory led to the
&gt;    invention of LUC in 1991. He can be reached at 25 Lawrence Street,
&gt;    Herne Bay, Auckland, New Zealand.
&gt;    
&gt;    
&gt;      _________________________________________________________________
&gt;    
&gt;    According to former NSA director Bobby Innman, public-key cryptography
&gt;    was discovered by the National Security Agency in the early seventies.
&gt;    At the time, pundits remarked that public-key cryptography (PKC) was
&gt;    like binary nerve gas--it was potent when two different substances
&gt;    were brought together, but quite innocuous in its separate parts.
&gt;    Because the NSA promptly classified it, not much was known about PKC
&gt;    until the mid-seventies when Martin Hellman and Whitfield Diffie
&gt;    independently came up with the notion and published papers about it.
&gt;    
&gt;    Traditional cryptographic systems like the venerable Data Encryption
&gt;    Standard (DES) use the same key at both ends of a message
&gt;    transmission. The problem of ensuring correct keys leads to such
&gt;    expensive expedients as distributing the keys physically with trusted
&gt;    couriers. Diffie and Hellman (and the NSA) had the idea of making the
&gt;    keys different at each end. In addition to encryption, they envisioned
&gt;    this scheme would also lead to a powerful means of source
&gt;    authentication known as digital signatures.
&gt;    
&gt;    RSA, developed in 1977, was the first reliable method of source
&gt;    authentication. The RSA approach (patented in the early eighties)
&gt;    initiated intense research in "number theory," one of the most
&gt;    recondite areas of mathematics. Although C.F. Gauss studied this topic
&gt;    in the early 1800s (referring to it then as "higher arithmetic"), very
&gt;    little real progress has been made in solving the problem of factoring
&gt;    since then. The means available today are essentially no better than
&gt;    exhaustive searching for prime factors. In terms of intractability
&gt;    theory, however, no one has yet proved that the problem is
&gt;    intractable, although researchers believe it to be so.
&gt;    
&gt;    
&gt;    
&gt; The RSA Algorithm
&gt; 
&gt;    
&gt;    
&gt;    RSA works by raising a message block to a very large power, then
&gt;    reducing this modulo N, where N (the product of two large prime
&gt;    numbers) is part of the key. Typical systems use an N of 512 bits, and
&gt;    the exponent to which blocks are raised in decryption is of the same
&gt;    order. An immediate problem in implementing such a system is the
&gt;    representation and efficient manipulation of such large integers.
&gt;    (Standard microprocessors don't really have the power to handle normal
&gt;    integer sizes and functions; even numeric coprocessors are inadequate
&gt;    when integers of this size are involved.)
&gt;    
&gt;    RSA has dominated public-key encryption for the last 15 years as
&gt;    research has failed to turn up a reliable alternative--until the
&gt;    advent of LUC. Based on the same difficult mathematical problem as
&gt;    RSA, LUC uses the calculation of Lucas functions instead of
&gt;    exponentiation. (See text box entitled, "How the Lucas Alternative
&gt;    Works.")
&gt;    
&gt;    Because we're working in the area of mathematics, we can formally
&gt;    prove that LUC is a true alternative to RSA. Furthermore, we can show
&gt;    that a cipher based on LUC will be at least as efficient. More
&gt;    importantly, we can show that LUC is a stronger cipher than RSA. The
&gt;    reason is that under RSA, the digital signature of a product is the
&gt;    product of the signatures making up the product; in mathematical
&gt;    terms, M{e}L{e}=(ML){e}. This opens RSA to a cryptographic attack
&gt;    known as adaptive chosen-message forgery. Ironically, this is outlined
&gt;    in a paper co-authored by Ron Rivest (the "R" in RSA). LUC is not
&gt;    multiplicative and therefore not susceptible to this attack. Using
&gt;    Lucas functions, V[e](M,1)V[e](L,1) is not equal to V[e](ML,1). In
&gt;    other words, the use of exponentiation leads to RSA being
&gt;    multiplicative in this way, while LUC's use of Lucas functions avoids
&gt;    this weakness.
&gt;    
&gt; Choosing the Algorithms
&gt; 
&gt;    
&gt;    
&gt;    Lucas functions have been studied mainly in relation to primality
&gt;    testing, and it was to these sources we turned when researching
&gt;    efficient algorithms for implementing LUC. For given parameters, the
&gt;    Lucas functions give rise to two series, U[n] and V[n]. The first
&gt;    algorithm (see Listing One, page 90) calculated both, even though we
&gt;    were only interested in V[n]. It was only in a paper on factoring
&gt;    integers that we found a means of calculating V[n] alone (see Listing
&gt;    Two, page 90). The pseudocode examples show that both algorithms have
&gt;    two phases: The work done when the current bit is a 0 is half the work
&gt;    necessary when the current bit is a 1.
&gt;    
&gt;    More Details.
&gt;    
&gt;    Typically, in systems like LUC the exponent used for encryption is a
&gt;    much smaller integer than that used for decryption. A commonly chosen
&gt;    encryption exponent is the prime number 65,537. This is a good choice
&gt;    for fast encryption as all but 2 of the 17 bits are 0s. We have no
&gt;    such control over the decryption exponent, but there is a way of
&gt;    halving the work, and thus, of introducing a limited degree of
&gt;    parallelism into the calculation.
&gt;    
&gt;    Since LUC is a public-key cryptosystem, we can always assume that the
&gt;    possessor of the private decrypting keys knows the two primes (p and
&gt;    q) which make up the modulus, N. Consequently, we can reduce the
&gt;    exponent and message with respect to the two primes, in each case at
&gt;    least halving the amount of work. At the end of the calculation with
&gt;    respect to the primes, we bring the results together to produce the
&gt;    final plain text (see Listing Three, page 90).
&gt;    
&gt; Large-integer Arithmetic
&gt; 
&gt;    
&gt;    
&gt;    There's really only one source of information about large-integer
&gt;    arithmetic: Knuth's The Art of Computer Programming. We found that
&gt;    almost every time we referred to his book, we came up with some new
&gt;    angle or way of tweaking some extra performance out of our code.
&gt;    
&gt;    We decided to represent the large integers as 256-byte arrays, with
&gt;    the low byte giving the length (in bytes) of the integer. For
&gt;    instance, the 8-byte hexadecimal number 1234567890ABCDEF would appear
&gt;    in a file view as 08 EF CD AB 90 78 56 34 12. These arrays became a
&gt;    Pascal-type har (for hexadecimal array). We can store integers of over
&gt;    600 decimal digits in our hars, but because the hars must be able to
&gt;    hold the results of a multiplication, we are limited to manipulating
&gt;    integers up to 300 decimal digits in length.
&gt;    
&gt;    Implementation of addition, subtraction, and multiplication went quite
&gt;    smoothly; implementation of division took more effort. (We took
&gt;    comfort in not being the first to encounter problems with division.
&gt;    Lady Ada Lovelace, the first computer programmer, said, "I am still
&gt;    working at some most entangled notations of division, but see my way
&gt;    through them at the expense of heavy labor, from which I shall not
&gt;    shrink as long as my head can bear it.") We tried various methods,
&gt;    including one based on Newton which calculated the inverse of the
&gt;    divisor and then multiplied. (See Knuth's discussion.) We finally
&gt;    opted for Knuth's Algorithm D, despite his warning that it contained
&gt;    possible discontinuities. At that stage, we were working on a 16-bit
&gt;    80286 PC; see Listing Four, page 90.
&gt;    
&gt;    Of course there was much more than the division routine to consider,
&gt;    but we found that it was the critical routine in terms of getting LUC
&gt;    to run at a reasonable speed. Once we had upgraded to an 80386, we
&gt;    converted to a full 32-bit implementation. The assembler code for the
&gt;    division (still Algorithm D) is given in Listing Five (page 91).
&gt;    Although space constraints prevent a complete presentation of the
&gt;    code, suffice to say that we have been able to achieve a
&gt;    signing/decryption speed on a modulus of 512 bits of over 200 bits per
&gt;    second (33-MHz 80386, 0 wait states).
&gt;    
&gt; Other Issues
&gt; 
&gt;    
&gt;    
&gt;    Central to any cryptographic system are keys. In LUC, if an adversary
&gt;    is able to find p and q, the prime factors of modulus N, then all
&gt;    messages sent with N can be either read in the case of encryption or
&gt;    forged in the case of signing.
&gt;    
&gt;    Since the days of Gauss, research on factoring has come up with
&gt;    various so-called "aleatoric" methods of factoring some numbers. These
&gt;    methods are like cures for poison ivy: numerous, and occasionally
&gt;    efficacious. One old method, found by Pierre Fermat, is very quick at
&gt;    factoring some types of composite numbers. If N is the product of two
&gt;    primes which are close together, then it can be easily factored. For
&gt;    example, if p=1949, and q=1951, then N=3802499. Taking the square root
&gt;    of N, we find that it is approximately 1949.999. Adding 1 to the
&gt;    integral part of this (giving 1950), we square this, giving 3802500.
&gt;    If we now subtract N from this square, we get a difference of 1, which
&gt;    is the square of itself. This means that N has been expressed as the
&gt;    difference of two squares. As we learned in high school, x{2}-y{2} =
&gt;    (x-y)(x+y), and so we obtain the two factors.
&gt;    
&gt;    Fermat's method works whenever the ratio of the factors is close to an
&gt;    integer. (Note that the ratio is close to 1 in the above discussion.)
&gt;    This attack, as cryptographers call methods used to break a cipher,
&gt;    has to be guarded against in generating the modulus N.
&gt;    
&gt;    Another guard is that neither (p + 1) and (q + 1) nor (p - 1) and (q -
&gt;    1) should be made up of small prime factors. There are many other
&gt;    guards of varying degrees of importance, but the entire area needs
&gt;    consideration depending on the level of security required, and how
&gt;    long the keys are meant to last.
&gt;    
&gt;    The basic idea behind LUC is that of providing an alternative to RSA
&gt;    by substituting the calculation of Lucas functions for that of
&gt;    exponentiation. While Lucas functions are somewhat more complex
&gt;    mathematically than exponentiation, they produce superior ciphers.
&gt;    
&gt;    This substitution process can be done with systems other than the RSA.
&gt;    Among these are the Hellman-Diffie-Merkle key exchange system (U.S.
&gt;    Patent number 4,200,770), the El Gamal public-key cryptosystem, the El
&gt;    Gamal digital signature, and the recently proposed Digital Signature
&gt;    Standard (DSS), all of which use exponentiation.
&gt;    
&gt;    The nonmultiplicative aspect of Lucas functions carries over, allowing
&gt;    us to produce alternatives to all these. In the case of the DSS, Lucas
&gt;    functions allow us to dispense with the one-way hashing cited (but not
&gt;    specified) in the draft standard.
&gt;    
&gt;    A New Zealand consortium has been set up to develop and license
&gt;    systems based on LUC, which is protected by a provisional patent. For
&gt;    more information, contact me or Horace R. Moore, 101 E. Bonita, Sierra
&gt;    Madre, California 91024.
&gt;    
&gt; References
&gt; 
&gt;    
&gt;    
&gt;    Athanasiou, Tom. "Encryption Technology, Privacy, and National
&gt;    Security." MIT Technology Review (August/September, 1986).
&gt;    
&gt;    Diffie, W. and M.E. Hellman. "New Directions in Cryptography." IEEE
&gt;    Transactions on Information Theory (November, 1976).
&gt;    
&gt;    El Gamal, Taher. "A Public Key Cryptosystem and a Signature Scheme
&gt;    Based on Discrete Logarithms." IEEE Transactions on Information Theory
&gt;    (July, 1985).
&gt;    
&gt;    Gauss, C.F. "Disquisitiones Arithmeticae," Article 329.
&gt;    
&gt;    Goldwasser, S., S. Micali, and R. Rivest. "A Digital Signature Scheme
&gt;    Secure Against Adaptive Chosen Message Attack." SIAM J. COMPUT (April,
&gt;    1988).
&gt;    
&gt;    Kaliski, Burton S., Jr. "Multiple-precision Arithmetic in C." Dr.
&gt;    Dobb's Journal (August, 1992).
&gt;    
&gt;    Knuth, D.E. The Art of Computer Programming: Volume II: Semi-Numerical
&gt;    Algorithms, second edition. Reading, MA: Addison-Wesley, 1981.
&gt;    
&gt;    Schneier, Bruce. "Untangling Public Key Cryptography." Dr. Dobb's
&gt;    Journal (May, 1992).
&gt;    
&gt;    Williams, H.C. "A p + 1 method of factoring." Mathematics of
&gt;    Computation (vol. 39, 1982).
&gt;    
&gt; How the Lucas Alternative Works
&gt; 
&gt;    
&gt;    
&gt;    As with RSA encryption, use of the Lucas alternative involves two
&gt;    public keys: N and e. The number N is assumed to be the product of two
&gt;    large (odd) prime numbers, p and q. Encryption and decryption of a
&gt;    message is achieved using Lucas sequences, which may be defined as
&gt;    shown in Example 1. Note that P and Q are integers.
&gt;    
&gt;    If a message P is to be sent, it is encoded as the residue P1 modulo N
&gt;    of the eth term of the Lucas sequence V[n](P,1), and then transmitted.
&gt;    The receiver uses a secret key d (based on the prime factorization of
&gt;    N) to decode the received message P1, by taking the residue modulo N
&gt;    of the dth term of the Lucas sequence V[n](P1,1). The secret key d is
&gt;    determined so that V[d](V[e](P,1),1) = P modulo N, ensuring the
&gt;    decryption of the received message P1 as P. The existence of such a
&gt;    key d is based on the following theorem.
&gt;    
&gt; Theorem
&gt; 
&gt;    
&gt;    
&gt;    Suppose N is any odd positive integer, and P is any positive integer,
&gt;    such as P{2}-4 is coprime to N. If r is the Lehmer totient function of
&gt;    N with respect to D = P{2}-4 (see Example 2), then V[mr+1](P,1)=P
&gt;    modulo N for every positive integer m. The condition that P{2}-4 be
&gt;    coprime to N is easily checked, as P{2}-4=(P+2)(P-2). Also, because
&gt;    V[d](V[e](P,1),1)=V[de](P,1), according to Example 4(e), the key d may
&gt;    simply be chosen so that de=1 modulo r.
&gt;    
&gt; The Lehmer Totient Function
&gt; 
&gt;    
&gt;    
&gt;    Suppose P and Q are integers, and a and b are the zeros of X{2}-Px+Q
&gt;    (so that P = a+b while Q = ab). Also, let D be the discriminant of
&gt;    x{2}-Px+Q. That is, D = P{2}-4Q = (a-b){2}.
&gt;    
&gt;    The Lucas sequences U[n] = U[n] (P,Q) and V[n] = V[n] (P,Q) are
&gt;    defined for n = 0,1,2, and so on by the equation in Example3.
&gt;    
&gt;    In particular, U[0] = 0, U[1] = 1, and then U[n+1] = PU[n] - QU[n-1]
&gt;    (for n = 1,2,3,...), while V[0] = 2, V[1] = P, and similarly V[n+1]=
&gt;    PV[n]-QV[n-1] (for n = 1,2,3,...). These sequences satisfy a number of
&gt;    identities, including the following which may be simply obtained from
&gt;    the definitions in Example 4.
&gt;    
&gt;    Next, suppose N is any positive integer, and let r be the Lehmer
&gt;    totient function of N with respect to D = P{2}-4Q, defined the same
&gt;    way as in the statement of the theorem. In the special case where N is
&gt;    an odd prime p, the Lehmer totient function of p with respect to D is
&gt;    the number given by the equation in Example 5(a). In this case, the
&gt;    Lucas-Lehmer theorem states that if p does not divide Q then the
&gt;    equation in Example 5(b) holds true.
&gt;    
&gt; Example of LUC
&gt; 
&gt;    
&gt;    
&gt;    Let N = pxq = 1949x2089=4071461, and P = 11111, which equals the
&gt;    message to encrypt/decrypt. The public keys will be e and N; the
&gt;    private key will be d. First, calculate r, the Lehmer totient function
&gt;    of P with respect to N. To do this we need to calculate the Legendre
&gt;    of p and q. Let D = p{2}-4; then (D/1949) =-1 and (D/2089)=-1 are the
&gt;    two Legendre values. Hence r is the least common multiple of 1949 + 1
&gt;    and 2089 + 1; see Example 6(a). Choosing e = 1103 for our public key,
&gt;    we use the Extended Euclidean Algorithm to find the secret key d, by
&gt;    solving the modular equation ed = 1 mod r. d turns out to equal 24017.
&gt;    
&gt;    To encrypt the message 11111, we make the calculation shown in Example
&gt;    6(b). To decrypt the encrypted message, we calculate as in Example
&gt;    6(c). --P.S.
&gt;    
&gt; 
&gt; _LUC PUBLIC-KEY ENCRYPTION_
&gt; by Peter Smith
&gt; 
&gt; 
&gt; [LISTING ONE]
&gt; 
&gt; { To calculate Ve(P,1) modulo N }
&gt;  Procedure LUCcalc;
&gt;  {Initialise}
&gt;  BEGIN
&gt;  D := P*P - 4; ut := 1; vt := P; u := ut; v := vt;
&gt;  If not odd(e) then BEGIN u := 0; v := 2; END;
&gt;  e := e div 2;
&gt;  {Start main}
&gt;  While e &gt; 0 do
&gt;    BEGIN
&gt;    ut := ut*vt mod N; vt := vt*vt mod N;
&gt;    If vt &lt; 3 then vt := vt + N;
&gt;    vt := vt - 2;
&gt;    If odd(e) then
&gt;      BEGIN
&gt;      c := (ut*v + u*vt) mod N;
&gt;      v := (vt*v + D*u*ut) mod N;
&gt;      If odd(v) then v := v + N; v := v/2;
&gt;      If odd(c) then c := c + N; u := c/2;
&gt;      END;
&gt;    e := e div 2;
&gt;    END;
&gt;  END;    {LUCcalc}
&gt; 
&gt; { The required result is the value of v.}
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; [LISTING TWO]
&gt; Pseudocode for calculating Lucas Functions
&gt; 
&gt; Procedure wiluc  {   V = V(M) Mod N, the Mth Lucas number(P,1) }
&gt; Var
&gt;                     V,Vb,P,Vf,N,M,NP, Vd, Vf : LargeInteger ;
&gt;                     carry, high_bit_set      : boolean ;
&gt;                     bz                        : word ;
&gt;   BEGIN
&gt;   Va := 2 ;   { V[0] }  Vb = P ;   { V[1] }
&gt;   NP := N - P; bz := bits(M) -1 ; { test bits from high bit downwards }
&gt;   For j := 1 to bz do
&gt;       BEGIN
&gt;       Vc := Vb * Vb; Vf = Vc ; If Vf &lt; 2 then Vf := Vf + N
&gt;       Vf := Vf - 2; Vd := Va * Vb
&gt;       {  Vc := V, Vd := V*Vb, Vf := V-2}
&gt;      If high_bit_set Then
&gt;           BEGIN
&gt;           Vb := P * Vc; If Vb &lt; Vd then Vb := Vb + N; Vb := Vb - Vd;
&gt;           If Vb &lt; P then Vb := Vb + N; Vb := Vb - P; Va := Vf
&gt;           END ;
&gt;      Else BEGIN { "even" ie high bit not set }
&gt;           Va := Vd; If Va &lt; P then Va := Va + N; Va := Va - P;
&gt;           Vb := Vf;
&gt;           END ;
&gt;      High_bit_set := next_bit_down(M);
&gt;      {This boolean function determines the setting of the next bit down}
&gt;      Va := Va Mod N; Vb := Vb Mod N
&gt;      END ; { for j to bz }
&gt; END ; {wiluc}
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; [LISTING THREE]
&gt; 
&gt; { Pseudocode for splitting decryption/signing over p and q
&gt;   (N = p*q) }
&gt; Procedure hafluc ( var s,p,q,m,e : LargeInteger ; qix : word ) ;
&gt; var                            ep,emq,
&gt;                                temp,pi,qi,
&gt;                                b,n,pa,qa : LargeInteger ;
&gt; 
&gt; { This procedure applies only to decipherment and signing, where the primes
&gt;   making up the modulus N ( = p * q) are known (or can be easily deduced,
&gt;   since both keys are known). Applying it allows us to halve the amount of
&gt;   work. Encipherment is usually done with a small key - standard is 65537. }
&gt;   Begin
&gt;   Qpr (pa,qa,p,q,m,qix ) ; {} {assumes qix already calculated }
&gt;   ep  = e ;              ep  = ep  Mod pa
&gt;   emq = e ;   emq  = emq Mod qa
&gt;   mp  = m ;    mp  = mp Mod p
&gt;   mq  = m ;    mq  = mq Mod q
&gt;   wiluc(q2,mq,emq,q) ;        wiluc(p2,mp,ep,p) ;
&gt;   if p2 &lt; q2 then
&gt;       Begin
&gt;       temp = q         q  = p    p  = temp
&gt;       temp = q2        q2 = p2   p2 = temp
&gt;       End ;
&gt;   temp = p2   temp = temp - q2
&gt;   n = p * q
&gt; { Solve with Extended Euclidean algorithm qi = 1/q Mod p. The algorithm
&gt; for the Extended Euclidean calculation can be found in Knuth. }
&gt;   r = temp * p
&gt;   r = r mod N
&gt;   s = r * qi
&gt;   s = s Mod n
&gt;   s = s + p2
&gt; End ; { hafluc }
&gt; Procedure SignVerify ;
&gt;   Begin
&gt;   h4 = 4
&gt;   p = large prime...
&gt;   q = large prime...
&gt;   n = p * q
&gt;   bz := bits(n) ;
&gt;     {write(cf,'  generate 4 keysets (d,e)  for p1,q1') ;}
&gt; {
&gt;       qix table for T[qix]
&gt;      Convention for qix
&gt;  This calculation is explained below.
&gt;    Lehmer totient      qix   Legendre values for p  and   q
&gt;    i.e. T[qix] = LCM
&gt;    (p - 1),(q - 1)     1                         1        1
&gt;    (p - 1),(q + 1)     2                         1       -1
&gt;    (p + 1),(q - 1)     3                        -1        1
&gt;    (p + 1),(q + 1)     4                        -1       -1
&gt;     e = encryption key,  small prime eg 65537
&gt;     mu = message as large integer less than n
&gt;     Solve e * d[qix] = 1 Mod T[qix] using Extended Euclidean Algorithm
&gt;     where T[qix] is lcm(p1,q1), the Lehmer totient function of N
&gt;     with repect to mu, according to the above table.
&gt;     This gives 4 possible values of d, the decryption/signing key.
&gt;     The particular value used depends on the message mu, as follows:
&gt;     Let D = mu2 - 4. Calculate the Legendre values of D with respect to
&gt;     both p and q. This value is -1 if D is a quadratic non-residue of
&gt;     p (or q), and equal to 1 if D is a quadratic residue of p (or q).
&gt;     N.B. This part is the most difficult part of LUC! Take care.
&gt; 
&gt;     Signing (Deciphering):
&gt;     hafluc (a,pu,qu,mu,d,qix)
&gt; 
&gt;     Verifying (Enciphering):
&gt;     Use Wiluc.
&gt; End.
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; [LISTING FOUR]
&gt; 
&gt; Algorithm D in 32-bit Intel assmbler
&gt; Author: Christopher T. Skinner
&gt; Short version of Mod32.Txt with scalings just as comments
&gt;                Modulus routine for Large Integers
&gt;                         u = u Mod v
&gt; Based on:
&gt; D.E.Knuth  The Art of Computer Programming
&gt;            Vol 2 Semi-Numerical Algorithms 2ed 1981
&gt;            Algorithm D page 257
&gt; We use a Pascal Type called "har" ( for "hexadecimal array")
&gt; Type
&gt;             har = Array[0..255] of byte ;
&gt; Var         u,v : har ;
&gt; Note that u[0] is the length of u and that the
&gt; integer begins in u[1]
&gt; It is desirable that u[1] is on a double word boundary.
&gt; 
&gt; ; Turbo Pascal Usage:      ( Turbo Pascal v6.0)
&gt; ; {$L Mod32a}   { contains mod32 far }
&gt; ; {$F+}   { far pointers }
&gt; ; procedure Mod32 ( var u,v : har ) ;
&gt; ; Turbo Assembler code: (TASM v2.01)--requires 32-bit chip ie 386 or 486
&gt; ; nb FS and GS can be used as temporary storage. Don't try to use them as
&gt; ; segment registers because Windows 3.0 restricts their allowed range, even
&gt; ; after you have finished out of Windows. You will hang for sure, unless you
&gt; ; have used a well-behaved protected-mode program to reset them, or cold boot.
&gt; 
&gt; Data    Segment Word Public Use16
&gt;     vdz     dw ?        ; size  v    words
&gt;     va  dd ?            ;     hi dword v
&gt;     vb  dd ?            ; 2nd     "    v
&gt;     vi  dw ?        ; ^v[1]
&gt;         savdi   dw ?            ; used in addback
&gt; Data    EndS
&gt; 
&gt; Code    Segment Word Public  Use16
&gt;     Assume  cs:Code, ds:Data ,es:Nothing
&gt;         Public  mod32
&gt; ; Pascal Parameters:
&gt; u   Equ DWord Ptr ss:[bp+10]      ; Parameter 1 of 2   (far)
&gt; v       Equ DWord Ptr ss:[bp+ 6]      ; parameter 2 of 2
&gt; uof     equ word ptr  ss:[bp+10]
&gt; vinof   equ word ptr  ss:[bp+ 6]
&gt; 
&gt; mod32   Proc    far
&gt;     push bp
&gt;     mov  bp,sp
&gt;         push di
&gt;         push si
&gt;         push ds          ; save the DS
&gt; 
&gt;         ; Before using Mod32 check that:
&gt;         ;     v &gt; 0
&gt;         ;     v &lt; u         u &lt;= 125 words
&gt;         ;     v[0] is a multiple of 4   and at least 8
&gt;         ;     v[top] &gt;= 80h           (may need to scale u &amp; v)
&gt;         ;     make u[0] = 0 Mod 4     (add 1..3 if required)
&gt; domod:
&gt;         ; now point to our v
&gt;         mov ax,seg v
&gt;         mov ds,ax
&gt;         assume ds:Data
&gt;         mov si, offset v
&gt;         cld
&gt;         assume es:Nothing
&gt;     xor ah,ah
&gt;     mov al,es:[di]   ; ax = size of u in bytes    "uz"
&gt;     mov cx,ax        ; cx = uz
&gt;     mov bx,ax        ; bx = uz
&gt;     mov al,[si]
&gt;     mov dx,ax    ; dx  = size v bytes
&gt;     shr ax,2
&gt;     mov vdz,ax   ; vdz    "     dwords   vz = 0 mod 4
&gt;     sub bx,dx        ; bx = uz - vz  difference in bytes
&gt;     mov ax,bx        ; ax = uz - vz
&gt;     sub ax,3     ; ax = uz - vz - 3     -&gt;  gs
&gt;     sub cx,3     ; cx =  uz - 3
&gt;     add cx,di        ; cx = ^top dword u
&gt;     add ax,di
&gt;     mov gs,ax    ; gs = ^(uz-vz-3)  u start   (by -4  down to 1)
&gt;         inc di
&gt;         mov fs,di    ; fs = uf = ^u[1] , end point
&gt;     inc si
&gt;     mov vi,si    ; vi = ^v[1]
&gt;     add si,dx
&gt;     mov eax,[si-4]
&gt;     mov va,eax   ;  va = high word of v
&gt;     mov eax,[si-8]
&gt;     mov vb,eax       ;  vb = 2nd highest word v
&gt;     mov di,cx    ; set di to ut , as at bottom of loop
&gt; d3:
&gt;     mov edx,es:[di]  ; dx is current high dword of u
&gt;     sub di,4
&gt;         mov eax,es:[di]  ; ax is current 2nd highest dword of u
&gt;     mov ecx,va
&gt;     cmp edx,ecx
&gt;     jae  aa          ; if high word u is 0 , never greater than
&gt;     div ecx      ;          mov ebx,eax
&gt;         mov esi,edx  ; si = rh
&gt;     jmp short ad     ; Normal route -- -- -- -- --&gt;
&gt; aa:     mov eax,0FFFFFFFFh
&gt;     mov edx,es:[di]  ; 2nd highest wrd u
&gt;     jmp short ac
&gt; ab: mov eax,ebx      ; q2
&gt;     dec eax
&gt;     mov edx,esi      ;  rh
&gt; ac: mov ebx,eax      ; q3
&gt;     add edx,ecx
&gt;     jc d4        ; Knuth tests overflow,
&gt;     mov esi,edx
&gt; ; normal route:
&gt;  ad:
&gt;         mul vb       ; Quotient by 2nd digit of divisor
&gt;     cmp edx,esi  ; high word of product : remainder
&gt;     jb  d4           ; no correction to quot, drop thru to mulsub
&gt;         ja  ab           ; nb unsigned use ja/b not jg/l
&gt;     cmp eax,es:[di-4] ; low word of product : 3rd high of u
&gt;     ja  ab
&gt; d4:          ; Multiply &amp; subtract * * * * * * *
&gt;     mov cx,gs
&gt;     mov di,cx    ; low start pos in u for subtraction of q * v
&gt;         sub cx,4
&gt;         mov gs,cx
&gt;         xor ecx,ecx
&gt;     Mov  cx,vdz  ; word count for q * v
&gt;         mov  si,vi   ; si points to v[1]
&gt;         xor ebp,ebp      ; carry 14Oct90 bp had problems in mu-lp
&gt;         even
&gt; ;    ** ** ** ** **  **  **  **
&gt; ba:     lodsd        ; eax &lt;- ds[si]
&gt;     mul ebx      ; dx:ax contains product   carry set if dx &gt; 0
&gt;         add eax,ebp
&gt;         adc edx,0
&gt;     sub es:[di],eax
&gt;         adc edx,0
&gt;         mov ebp,edx
&gt;         add di,4
&gt;     loop ba      ; dec cx , jmp if not 0
&gt; ; .. .. .. . .. .. . .. .. . .. . . ..
&gt;         sub es:[di],edx
&gt;         jnc d7
&gt; 
&gt;     mov si,vi    ;  add back (rare)
&gt;         mov savdi,di
&gt;     mov di,gs
&gt;         add di,4
&gt;     clc
&gt;     mov cx,vdz
&gt; bb:     lodsd        ; eax = ds[si]   si + 2
&gt;     adc es:[di],eax
&gt;         inc di
&gt;         inc di
&gt;         inc di
&gt;         inc di
&gt;         loop bb
&gt;         xor eax,eax
&gt;         mov es:[di],eax
&gt;         mov di,savdi
&gt;         ; test with:
&gt;         ; 1,00000000,00000000,00000001/ 80000000,00000000,00000001
&gt; d7:
&gt;     mov bx,fs     ; fs ^u[1]
&gt;         mov ax,gs     ; gs = current u start position
&gt;     cmp ax,bx     ; current - bottom
&gt;     jb d8
&gt;         sub di,4
&gt;     jmp d3
&gt; d8:
&gt; ; here we would scale u down if it had been scaled up
&gt; quex:                 ; quick exit if v &lt; u
&gt;         cld              ; just in case
&gt;         pop ds
&gt;         pop si
&gt;         pop di
&gt;         pop bp
&gt;     ret 8       ; 2 pointers = 4 words = 8 bytes
&gt; mod32   EndP        ;
&gt; Code    Ends
&gt;     End
&gt; 
&gt; 
&gt; 
&gt; 
&gt; 
&gt; [LISTING FIVE]
&gt; 
&gt; Algorithm D in 16-bit Intel assembler
&gt; Author: Christopher T. Skinner
&gt;    mod16.txt 21 Au8 92     16 bit modulus
&gt; ; divm  Modulus
&gt; Data    Segment Word Public
&gt;     vwz     dw ?        ; size  v    words
&gt;     va  dw ?            ;     hi word v
&gt;     vb  dw ?            ; 2nd    "    v
&gt;     vi  dw ?        ; ^v[1]
&gt;     uf  dw ?        ; ^u[3]
&gt;     uz  dw ?            ; size u byte
&gt;     vz  dw ?             ;   "   v  "
&gt;     ua      dw ?        ; ^( u[0] + uz - vz -1 ) , mul sub start
&gt;     ut  dw ?            ; ^ u[topword]
&gt;     qh      dw ?
&gt;     uzofs   dw ?        ; ttt
&gt;     vzofs   dw ?        ; ttt
&gt; Data    EndS
&gt; Code    Segment Word Public
&gt;     Assume  cs:Code, ds:Data
&gt;         Public  diva
&gt; 
&gt; u   Equ DWord Ptr [bp+10]       ; ES:DI
&gt; v       Equ DWord Ptr [bp+6]        ; DS:SI
&gt;     ; NB v Must be Global, DS based...
&gt; diva    Proc    far
&gt;     push bp
&gt;     mov  bp,sp
&gt;         push ds
&gt;     cld     ; increment lodsw in mulsub
&gt;     lds si,v
&gt;         les di,u
&gt;     xor ah,ah
&gt;     mov al,es:[di]  ; ax = uz size of u in bytes N.B. uz is not actually used
&gt;     mov cx,ax       ; cx = uz
&gt;     mov bx,ax       ; bx = uz
&gt;     mov al,ds:[si]
&gt;     mov dx,ax   ; dx  = size v bytes
&gt;     shr ax,1
&gt;     mov vwz,ax  ; vwz    "     words
&gt;     sub bx,dx       ; bx = uz - vz  difference in bytes
&gt;     mov ax,bx       ; ax = uz - vz
&gt;     dec ax      ; ax = uz - vz - 1     -&gt;  ua
&gt;     dec cx      ; cx =  uz - 1
&gt;     add cx,di       ; cx = ^top word u
&gt;     mov ut,cx   ; ut = ^top word u
&gt;     add ax,di
&gt;     mov ua,ax   ; ua = ^(uz-vz-1)  u start   (by -2  down to 1)
&gt;         inc di
&gt;     mov uf,di   ; uf = ^u[1] , end point
&gt;     inc si
&gt;     mov vi,si   ; vi = ^v[1]
&gt;     add si,dx
&gt;     mov ax,ds:[si-2]
&gt;     mov va,ax   ;  va = high word of v
&gt;     mov ax,ds:[si-4]
&gt;     mov vb,ax       ;  vb = 2nd highest word v
&gt;     mov di,cx   ; set di to ut , as at bottom of loop
&gt; d3:
&gt;     mov dx,es:[di]          ; dx is current high word of u
&gt;     dec di
&gt;     dec di
&gt;     mov ut,di
&gt;         mov ax,es:[di]        ; ax is current 2nd highest word of u
&gt;     mov cx,va
&gt;     cmp dx,cx
&gt;     jae  aa   ;if high word u is 0 , never greater than
&gt;     div cx          ;
&gt;         mov qh,ax
&gt;         mov si,dx       ; si = rh
&gt;     jmp ad          ; Normal route -- -- -- -- --&gt;
&gt; aa:     mov ax,0FFFFh
&gt;     mov dx,es:[di]      ; 2nd highest wrd u
&gt;     jmp ac
&gt; ab: mov ax,qh
&gt;     dec ax
&gt;     mov dx,si       ;  rh
&gt; ac: mov qh,ax
&gt;     add dx,cx
&gt;     jc d4           ; Knuth tests overflow,
&gt;     mov si,dx
&gt; ad:     mul vb          ; Quotient by 2nd digit of divisor
&gt;     cmp dx,si       ; high word of product : remainder
&gt;     jb  d4          ; no correction to quot, drop thru to mulsub
&gt;         ja  ab          ; nb unsigned use ja/b not jg/l
&gt;     cmp ax,es:[di-2]    ; low word of product : 3rd high of u
&gt;     ja  ab
&gt; d4:         ; Multiply &amp; subtract * * * * * * *
&gt;     mov bx,ua
&gt;     mov di,bx   ; low start pos in u for subtraction of q * v
&gt;     dec bx
&gt;     dec bx      ;
&gt;     mov ua,bx
&gt;     Mov  cx,vwz ; word count for q * v
&gt;         mov  si,vi  ; si points to v[1]
&gt;     mov bx,qh
&gt;         xor bp,bp
&gt; ;    ** ** ** ** **  **  **  **
&gt; ba:     lodsw       ; ax &lt;- ds[si]   si + 2  preserve carry over mul ?
&gt;     mul bx      ; dx:ax contains product   carry set if dx &gt; 0
&gt;     add dx,bp
&gt;         xor bp,bp
&gt;     sub es:[di],ax
&gt;     inc di
&gt;     inc di
&gt;     sbb es:[di],dx
&gt;     rcl bp,1
&gt;     loop ba     ; dec cx , jmp if not 0
&gt; ; .. .. .. . .. .. . .. .. . .. . . ..
&gt;         rcr bp,1
&gt;         jnc d7
&gt; 
&gt;     mov si,vi   ;  add back (rare)
&gt;     mov di,ua
&gt;        inc di
&gt;     inc di
&gt;     clc
&gt;     mov cx,vwz
&gt; bb:    lodsw        ; ax = ds[si]   si + 2
&gt;     adc es:[di],ax
&gt;     inc di
&gt;     inc di
&gt;     loop bb
&gt;     mov cx,ut
&gt;     add cx,4
&gt;     sub cx,di
&gt;     shr cx,1        ; word length of u
&gt; bc:    mov Word Ptr es:[di],0
&gt;        inc di
&gt;     inc di
&gt;        loop bc  ;
&gt;     dec di      ;
&gt;     dec di      ;
&gt;     clc
&gt; d7:
&gt;     mov ax,uf
&gt;     cmp ua,ax
&gt;     jb d8
&gt;     dec di      ; New these are suspicious, with an add back and a
&gt;     dec di      ; New
&gt;     jmp d3
&gt; d8:
&gt;              cld   ; just in case
&gt;        pop ds
&gt;     pop bp
&gt;     ret 8       ; 2 pointers = 4 words = 8 bytes ???
&gt; diva    EndP        ;
&gt; Code    Ends
&gt;     End
&gt; 
&gt;    
&gt;      _________________________________________________________________
&gt;    
&gt;    Copyright &amp;copy; 1998, Dr. Dobb's Journal
&gt;    Dr. Dobb's Web Site Home Page -- Top of This Page
&gt;    
&gt; 


</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00403.html">Re: Spam</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00378.html">RB_Fermat.html</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00375.html">Gauss.html</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00378.html">RB_Fermat.html</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00377"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00377"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
