<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: Entropy, Randomness, etc. -->
<!--X-From-R13: gpznlNargpbz.pbz (Fvzbgul Q. [nl) -->
<!--X-Date: Thu, 2 Dec 93 20:03:42 PST -->
<!--X-Message-Id: 199312030402.UAA26750@mail.netcom.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 9312030219.AA08840@ininx -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: Entropy, Randomness, etc.</TITLE>
<LINK REV="made" HREF="mailto:tcmay@netcom.com">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00067.html">Date Prev</A>][<A HREF="msg00071.html">Date Next</A>][<A HREF="msg00067.html">Thread Prev</A>][<A HREF="msg00099.html">Thread Next</A>][<A HREF="index.html#00068">Date Index</A>][<A HREF="threads.html#00068">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: Entropy, Randomness, etc.</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Subject</em>: Re: Entropy, Randomness, etc.</LI>
<LI><em>From</em>: <A HREF="mailto:tcmay@netcom.com">tcmay@netcom.com</A> (Timothy C. May)</LI>
<LI><em>Date</em>: Thu, 2 Dec 93 20:02:30 PST</LI>
<LI><em>In-Reply-To</em>: &lt;<A HREF="msg00064.html">9312030219.AA08840@ininx</A>&gt;; from "John E. Kreznar" at Dec 2, 93 6:19 pm</LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
John Kreznar writes:

&gt; &gt; Give a particular set of data used to generate a random key, such as,
&gt; &gt; a unix box's /dev/mem, how can one measure the number of bits of
&gt; &gt; entropy?
&gt; 
&gt; Actually, it can't be done.  The consistent measure of entropy for
&gt; finite objects like a string or a (finite) series of random numbers is
&gt; the so-called ``program length complexity''.  This is defined as the
&gt; length of the shortest program for some given universal Turing machine
&gt; which computes the string.  It's consistent in the sense that it has the
&gt; familiar properties of ``ordinary'' (Shannon) entropy.  Unfortunately,
&gt; it's uncomputable: there's no algorithm which, given an arbitrary finite
&gt; string S, computes the program-length complexity of S.

The intuitive idea is similar to there being no "maximum compression"
of a string: though one may strongly suspect a compression is pretty
good and may in fact be the best there really is, one may find an even
better compression. Like the "pi" example Scott Collins used.

Still, one can make estimates of the entropy of a string.

&gt; Program-length complexity is well-studied in the literature.  A good
&gt; introductory paper is ``A Theory of Program Size Formally Identical to
&gt; Information Theory'' by  G. J. Chaitin, _Journal of the ACM_, 22 (1975)
&gt; reprinted in Chaitin's book _Information Randomness &amp; Incompleteness_,
&gt; World Scientific Publishing Co., 1990.

And an especially good place to read all about this is in the new book
by Ming Li and Paul Vitanyi, "An Introduction to Kolmogorov Complexity
and Its Applications," Springer-Verlag, 1993. $60.

Lots of good chapters on entropy, program length measures, algorithmic
information theory, etc. Ironically, no mention of cryptology at all.
(But Charles Bennett, one of the pioneers--especially in the area of
"logical depth"--has written about the deep links between the two
areas. Basically, ciphertext messages are "cryptoregular" in that they
_appear_ to be of high entropy (random) but actually have low entropy
when of course the right transformation (key) is applied.

You clever folks will by now have seen the link to the opening
discussion: how does one know if a given text is "cryptoregular" and
actually carries a message or is just random junk? The answer in
general is that no mechanistic/algorithmic method exists!

(Hardly surprising, if you think about it. A one-time pad is
information-theoretically secure. Every English (or Russian, etc.)
sentence of length L can be "found" in a cyphertext of length L by
trying the "right" pad. A thousand monkeys and all that.)

For messages that are not encrypted with one-time pads, this is
not the case, and various bits of information can sometimes be
extracted. Cryptanalysis sometimes works. Last I heard, though, it
doesn't help with breaking RSA (chosen plaintext attacks on RSA don't
help with the factoring problem at all...consult the textbooks on the
exact situation, if you're interested in such subtleties).

Kolmogorov-Chaitin measures of complexity are very exciting.

--Tim May


-- 
..........................................................................
Timothy C. May         | Crypto Anarchy: encryption, digital money,  
tcmay@netcom.com       | anonymous networks, digital pseudonyms, zero
408-688-5409           | knowledge, reputations, information markets, 
W.A.S.T.E.: Aptos, CA  | black markets, collapse of governments.
Higher Power: 2^756839 | Public Key: PGP and MailSafe available.
Note: I put time and money into writing this posting. I hope you enjoy it.

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="00064" HREF="msg00064.html">Re: Entropy, Randomness, etc.</A></STRONG>
<UL><LI><EM>From:</EM> jkreznar@ininx.com (John E. Kreznar)</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00067.html">Re: Entropy, Randomness, etc.</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00071.html">Mac Encryption Program Ready!</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00067.html">Re: Entropy, Randomness, etc.</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00099.html">Re: Entropy, Randomness, etc.</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00068"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00068"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
