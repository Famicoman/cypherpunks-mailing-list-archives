<!-- MHonArc v2.4.3 -->
<!--X-Subject: multiple&#45;file encryption -->
<!--X-From-R13: pzrNryyvfha.fj.fgenghf.pbz (Qney Syyvfba) -->
<!--X-Date: Mon, 4 Oct 93 14:24:51 PDT -->
<!--X-Message-Id: 9310042122.AA15704@ellisun.sw.stratus.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>multiple-file encryption</TITLE>
<LINK REV="made" HREF="mailto:cme@ellisun.sw.stratus.com">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00175.html">Date Prev</A>][<A HREF="msg00178.html">Date Next</A>][<A HREF="msg00159.html">Thread Prev</A>][<A HREF="msg00178.html">Thread Next</A>][<A HREF="index.html#00176">Date Index</A>][<A HREF="threads.html#00176">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>multiple-file encryption</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Subject</em>: multiple-file encryption</LI>
<LI><em>From</em>: <A HREF="mailto:cme@ellisun.sw.stratus.com">cme@ellisun.sw.stratus.com</A> (Carl Ellison)</LI>
<LI><em>Date</em>: Mon, 4 Oct 93 17:22:54 EDT</LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
&gt;Date: Mon, 04 Oct 93 14:29:44 MDT
&gt;From: "Mike Johnson" &lt;exabyte!smtplink!mikej@uunet.UU.NET&gt;
&gt;Message-Id: &lt;<A HREF="msg00161.html">9309047497.AA749770184@smtplink.exabyte.com</A>&gt;
&gt;Subject: Re[2]: POISON PILL

&gt;Yes.  Make "noise addition" (really multiplexing) part of the cipher.  You
&gt;could throw away every other bit based on the parity of the key.  The
&gt;ciphertext would be twice as big, but if you compressed both plain text
&gt;streams first, this effect might not be very obvious.  Of course, if your
&gt;encryption program were disassembled, you might be found out...


Yup -- I was assuming no padding.

If you allow padding, I already have a secret-key cipher which uses random
padding in order to frustrate known-plaintext attacks.  My favorite method
uses a key to initialize a PRNG whose output gives the number of bytes of
each stream to put in the output stream -- then encipher the PRNG key
followed by the multiplexed stream.  One of the streams being multiplexed
(and there can be a huge number, if you're encrypting an archive, for
example) can and should be random -- so that if you make a small change
and re-encrypt, you don't end up with cribs.

For this purpose, you'd need to have several files hanging around your
machine of random numbers yet to be used for padding.

Meanwhile, I have several files of random numbers which I keep around for
running simulations.

My favorite random number generator is

	compress - &lt;/dev/audio | idea | tran | idea | tran | idea

where the idea keys are chosen randomly and there's no mic plugged in
at /dev/audio.

Other people might generate random numbers other ways. :-)
[but you might keep my method around, for demonstrating to the cops.]

 - Carl


</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00175.html">Re: Who's Most Receptive to Our Message?</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00178.html">unscubscribe</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00159.html">2-part LA Times story</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00178.html">unscubscribe</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00176"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00176"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
