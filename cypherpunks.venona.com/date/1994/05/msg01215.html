<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: Secure RPC? -->
<!--X-From-R13: Qlaguvn Qynex <ppynexNQ@DW.Drfgba.HO.GE> -->
<!--X-Date: Fri, 20 May 94 12:34:26 PDT -->
<!--X-Message-Id: 9405201528.aa11938@IETF.CNRI.Reston.VA.US -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 9405201854.AA15841@deathstar.iaks.ira.uka.de -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: Secure RPC?</TITLE>
<LINK REV="made" HREF="mailto:cclark@CNRI.Reston.VA.US">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg01226.html">Date Prev</A>][<A HREF="msg01207.html">Date Next</A>][<A HREF="msg01210.html">Thread Prev</A>][<A HREF="msg01226.html">Thread Next</A>][<A HREF="index.html#01215">Date Index</A>][<A HREF="threads.html#01215">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: Secure RPC?</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: Hadmut Danisch &lt;<A HREF="mailto:danisch@ira.uka.de">danisch@ira.uka.de</A>&gt;</LI>
<LI><em>Subject</em>: Re: Secure RPC? </LI>
<LI><em>From</em>: Cynthia Clark &lt;<A HREF="mailto:cclark@CNRI.Reston.VA.US">cclark@CNRI.Reston.VA.US</A>&gt;</LI>
<LI><em>Date</em>: Fri, 20 May 94 15:28:20 -0400</LI>
<LI><em>Cc</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A>, <A HREF="mailto:cclark@CNRI.Reston.VA.US">cclark@CNRI.Reston.VA.US</A></LI>
<LI><em>In-Reply-To</em>: Your message of "Fri, 20 May 94 20:54:58 +0200."            &lt;<A HREF="msg01228.html">9405201854.AA15841@deathstar.iaks.ira.uka.de</A>&gt; </LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@toad.com">owner-cypherpunks@toad.com</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>



 &gt; where can I get specs and informations about secure RPC?


Hello Hadmut,

I'm forwarding the Internet Draft &lt;draft-ietf-oncrpc-rpcv2-00.txt&gt;
below.  Is this exactly what you're looking for ?

Anyone can retrieve these I-Ds by using the anonymous ftp at ds.internic.net 
cd /ftp/internet-drafts  

For more information about RPC, you might want to contact
Raj Srinivasan at &lt;raj.srinivasan@eng.sun.com&gt;

If you have any other questions, please do not hesitate to 
contact me directly.  I might help as a "pointer".

Kind Regards,

Cynthia Clark
Internet Drafts Administrator

 -----  Forwarded Message  ------



INTERNET-DRAFT                                         Raj Srinivasan
March 4, 1994                                          Sun Microsystems

        RPC: Remote Procedure Call Protocol Specification Version 2

                      ietf-draft-oncrpc-rpcv2-00.txt


ABSTRACT

This document describes Sun Microsystems' Remote Procedure Call (ONC RPC
Version 2) protocol as it is currently deployed and accepted.

STATUS OF THIS MEMO

Internet Drafts are working documents of the Internet Engineering Task
Force (IETF), its Areas, and its Working Groups.  Note that other groups
may also distribute working documents as Internet Drafts.

Internet Drafts are draft documents valid for a maximum of six months.
This Internet Draft expires on October 4, 1994.  Internet Drafts may be
updated, replaced, or obsoleted by other documents at any time. It is not
appropriate to use Internet Drafts as reference material or to cite them
other than as a "working draft" or "work in progress."

Please check the I-D abstract listing contained in each Internet Draft
directory to learn the current status of this or any other Internet Draft.

Distribution of this memo is unlimited.



























Expires: October 4, 1994                                   [Page 1]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


CONTENTS

   1. INTRODUCTION
   2. TERMINOLOGY
   3. THE RPC MODEL
   4. TRANSPORTS AND SEMANTICS
   5. BINDING AND RENDEZVOUS INDEPENDENCE
   6. AUTHENTICATION
   7. RPC PROTOCOL REQUIREMENTS
   7.1 RPC Programs and Procedures
   7.2 Authentication
   7.3 Program Number Assignment
   7.4 Other Uses of the RPC Protocol
   7.4.1 Batching
   7.4.2 Broadcast Remote Procedure Calls
   8. THE RPC MESSAGE PROTOCOL
   9. AUTHENTICATION PROTOCOLS
   9.1 Null Authentication
   9.2 System Authentication
   9.3 DES Authentication
   9.3.1 Naming
   9.3.2 DES Authentication Verifiers
   9.3.3 Nicknames and Clock Synchronization
   9.3.4 DES Authentication Protocol Specification
   9.3.4.1 The Full Network Name Credential and Verifier (Client)
   9.3.4.2 The Nickname Credential and Verifier (Client)
   9.3.4.3 The Nickname Verifier (Server)
   9.3.5 Diffie-Hellman Encryption
   9.4 Kerberos-based Authentication
   9.4.1 Kerberos-based Authentication Protocol Specification
   9.4.1.1 The Full Network Name Credential and Verifier (Client)
   9.4.1.2 The Nickname Credential and Verifier (Client)
   9.4.1.3 The Nickname Verifier (Server)
   10. RECORD MARKING STANDARD
   11. THE RPC LANGUAGE
   11.1 An Example Service Described in the RPC Language
   11.2 The RPC Language Specification
   11.3 Syntax Notes
   APPENDIX A: RPCBIND PROGRAM PROTOCOL
   A.1 RPCBIND Protocol Specification (in RPC Language)
   A.2 RPCBIND Operation
   A.2.1 RPCBIND Version 3
   A.2.2 RPCBIND, Version 4
   APPENDIX B: PORT MAPPER PROGRAM PROTOCOL
   B.1 Port Mapper Protocol Specification (in RPC Language)
   B.2 Port Mapper Operation
   REFERENCES









Expires: October 4, 1994                                   [Page 2]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


1. INTRODUCTION

This document specifies version two of the message protocol used in Sun's
Remote Procedure Call (RPC) package.  The message protocol is specified
with the eXternal Data Representation (XDR) language [9].  This document
assumes that the reader is familiar with XDR.  It does not attempt to
justify remote procedure calls systems or describe their use.  The paper by
Birrell and Nelson [1] is recommended as an excellent background for the
remote procedure call concept.

2. TERMINOLOGY

This document discusses clients, calls, servers, replies, services,
programs, procedures, and versions.  Each remote procedure call has two
sides: an active client side that makes the call to a server, which sends
back a reply.  A network service is a collection of one or more remote
programs.  A remote program implements one or more remote procedures; the
procedures, their parameters, and results are documented in the specific
program's protocol specification (see Appendix A for an example).  A server
may support more than one version of a remote program in order to be
compatible with changing protocols.

For example, a network file service may be composed of two programs.  One
program may deal with high-level applications such as file system access
control and locking.  The other may deal with low-level file input and
output and have procedures like "read" and "write".  A client of the
network file service would call the procedures associated with the two
programs of the service on behalf of the client.

The terms client and server only apply to a particular transaction; a
particular hardware entity (host) or software entity (process or program)
could operate in both roles at different times.  For example, a program
that supplies remote execution service could also be a client of a network
file service.

3. THE RPC MODEL

The Sun RPC protocol is based on the remote procedure call model, which is
similar to the local procedure call model.  In the local case, the caller
places arguments to a procedure in some well- specified location (such as a
register window).  It then transfers control to the procedure, and
eventually regains control.  At that point, the results of the procedure
are extracted from the well- specified location, and the caller continues
execution.

The remote procedure call model is similar.  One thread of control
logically winds through two processes: the caller's process, and a server's
process.  The caller process first sends a call message to the server
process and waits (blocks) for a reply message.  The call message includes
the procedure's parameters, and the reply message includes the procedure's
results.  Once the reply message is received, the results of the procedure
are extracted, and caller's execution is resumed.




Expires: October 4, 1994                                   [Page 3]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


On the server side, a process is dormant awaiting the arrival of a call
message.  When one arrives, the server process extracts the procedure's
parameters, computes the results, sends a reply message, and then awaits
the next call message.

In this model, only one of the two processes is active at any given time.
However, this model is only given as an example.  The Sun RPC protocol
makes no restrictions on the concurrency model implemented, and others are
possible.  For example, an implementation may choose to have RPC calls be
asynchronous, so that the client may do useful work while waiting for the
reply from the server.  Another possibility is to have the server create a
separate task to process an incoming call, so that the original server can
be free to receive other requests.

There are a few important ways in which remote procedure calls differ from
local procedure calls:

1. Error handling: failures of the remote server or network must be handled
when using remote procedure calls.

2. Global variables and side-effects: since the server does not have access
to the client's address space, hidden arguments cannot be passed as global
variables or returned as side effects.

3. Performance:  remote procedures usually operate one or more orders of
magnitude slower than local procedure calls.

4. Authentication: since remote procedure calls can be transported over
unsecured networks, authentication may be necessary.  Authentication
prevents one entity from masquerading as some other entity.

The conclusion is that even though there are tools to automatically
generate client and server libraries for a given service, protocols must
still be designed carefully.

4. TRANSPORTS AND SEMANTICS

The RPC protocol can be implemented on several different transport
protocols.  The RPC protocol does not care how a message is passed from one
process to another, but only with specification and interpretation of
messages.  However, the application may wish to obtain information about
(and perhaps control over) the transport layer through an interface not
specified in this document.  For example, the transport protocol may impose
a restriction on the maximum size of RPC messages, or it may be stream-
oriented like TCP with no size limit.  The client and server must agree on
their transport protocol choices, through a mechanism such as the one
described in Appendix A.

It is important to point out that RPC does not try to implement any kind of
reliability and that the application may need to be aware of the type of
transport protocol underneath RPC.  If it knows it is running on top of a
reliable transport such as TCP [6], then most of the work is already done
for it.  On the other hand, if it is running on top of an unreliable



Expires: October 4, 1994                                   [Page 4]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


transport such as UDP [7], it must implement its own time-out,
retransmission, and duplicate detection policies as the RPC protocol does
not provide these services.

Because of transport independence, the RPC protocol does not attach
specific semantics to the remote procedures or their execution
requirements.  Semantics can be inferred from (but should be explicitly
specified by) the underlying transport protocol.  For example, consider RPC
running on top of an unreliable transport such as UDP.  If an application
retransmits RPC call messages after time- outs, and does not receive a
reply, it cannot infer anything about the number of times the procedure was
executed.  If it does receive a reply, then it can infer that the procedure
was executed at least once.

A server may wish to remember previously granted requests from a client and
not regrant them in order to insure some degree of execute-at-most-once
semantics.  A server can do this by taking advantage of the transaction ID
that is packaged with every RPC message.  The main use of this transaction
ID is by the client RPC entity in matching replies to calls.  However, a
client application may choose to reuse its previous transaction ID when
retransmitting a call.  The server may choose to remember this ID after
executing a call and not execute calls with the same ID in order to achieve
some degree of execute-at-most-once semantics.  The server is not allowed
to examine this ID in any other way except as a test for equality.

On the other hand, if using a "reliable" transport such as TCP, the
application can infer from a reply message that the procedure was executed
exactly once, but if it receives no reply message, it cannot assume that
the remote procedure was not executed.  Note that even if a connection-
oriented protocol like TCP is used, an application still needs time-outs
and reconnection to handle server crashes.

There are other possibilities for transports besides datagram- or
connection-oriented protocols.  For example, a request-reply protocol such
as VMTP [2] is perhaps a natural transport for RPC.  The Sun RPC package
currently uses both TCP and UDP transport protocols.

5. BINDING AND RENDEZVOUS INDEPENDENCE

The act of binding a particular client to a particular service and
transport parameters is NOT part of this RPC protocol specification.  This
important and necessary function is left up to some higher-level software.
(The software may use RPC itself; see Appendix A.)

Implementors could think of the RPC protocol as the jump-subroutine
instruction ("JSR") of a network; the loader (binder) makes JSR useful, and
the loader itself uses JSR to accomplish its task.  Likewise, the binding
software makes RPC useful, possibly using RPC to accomplish this task.

6. AUTHENTICATION

The RPC protocol provides the fields necessary for a client to identify
itself to a service, and vice-versa, in each call and reply message.



Expires: October 4, 1994                                   [Page 5]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


Security and access control mechanisms can be built on top of this message
authentication.  Several different authentication protocols can be
supported.  A field in the RPC header indicates which protocol is being
used. More information on specific authentication protocols is in section
9: "Authentication Protocols".

7. RPC PROTOCOL REQUIREMENTS

The RPC protocol must provide for the following:

(1) Unique specification of a procedure to be called.  (2) Provisions for
matching response messages to request messages.  (3) Provisions for
authenticating the caller to service and vice-
    versa.

Besides these requirements, features that detect the following are worth
supporting because of protocol roll-over errors, implementation bugs, user
error, and network administration:

(1) RPC protocol mismatches.  (2) Remote program protocol version
mismatches.  (3) Protocol errors (such as misspecification of a procedure's
    parameters).  (4) Reasons why remote authentication failed.  (5) Any
other reasons why the desired procedure was not called.

7.1 RPC Programs and Procedures

The RPC call message has three unsigned integer fields -- remote program
number, remote program version number, and remote procedure number -- which
uniquely identify the procedure to be called.  Program numbers are
administered by some central authority (like Sun).  Once implementors have
a program number, they can implement their remote program; the first
implementation would most likely have the version number 1.  Because most
new protocols evolve, a version field of the call message identifies which
version of the protocol the caller is using.  Version numbers enable
support of both old and new protocols through the same server process.

The procedure number identifies the procedure to be called.  These numbers
are documented in the specific program's protocol specification.  For
example, a file service's protocol specification may state that its
procedure number 5 is "read" and procedure number 12 is "write".

Just as remote program protocols may change over several versions, the
actual RPC message protocol could also change.  Therefore, the call message
also has in it the RPC version number, which is always equal to two for the
version of RPC described here.

The reply message to a request message has enough information to
distinguish the following error conditions:

(1) The remote implementation of RPC does not support protocol version 2.
The lowest and highest supported RPC version numbers are returned.

(2) The remote program is not available on the remote system.



Expires: October 4, 1994                                   [Page 6]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


(3) The remote program does not support the requested version number.  The
lowest and highest supported remote program version numbers are returned.

(4) The requested procedure number does not exist.  (This is usually a
client side protocol or programming error.)

(5) The parameters to the remote procedure appear to be garbage from the
server's point of view.  (Again, this is usually caused by a disagreement
about the protocol between client and service.)

7.2 Authentication

Provisions for authentication of caller to service and vice-versa are
provided as a part of the RPC protocol.  The call message has two
authentication fields, the credential and verifier.  The reply message has
one authentication field, the response verifier.  The RPC protocol
specification defines all three fields to be the following opaque type (in
the eXternal Data Representation (XDR) language [9]):

      enum auth_flavor {
         AUTH_NONE       = 0,
         AUTH_SYS        = 1,
         AUTH_SHORT      = 2,
         AUTH_DES        = 3,
         AUTH_KERB       = 4
         /* and more to be defined */
      };

      struct opaque_auth {
         auth_flavor flavor;
         opaque body&lt;400&gt;;
      };

In other words, any "opaque_auth" structure is an "auth_flavor" enumeration
followed by up to 400 bytes which are opaque to (uninterpreted by) the RPC
protocol implementation.

The interpretation and semantics of the data contained within the
authentication fields is specified by individual, independent
authentication protocol specifications.  (Section 9 defines the various
authentication protocols.)

If authentication parameters were rejected, the reply message contains
information stating why they were rejected.

7.3 Program Number Assignment

Program numbers are given out in groups of hexadecimal 20000000 (decimal
536870912) according to the following chart:







Expires: October 4, 1994                                   [Page 7]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


              0 - 1fffffff   defined by Sun
       20000000 - 3fffffff   defined by user
       40000000 - 5fffffff   transient
       60000000 - 7fffffff   reserved
       80000000 - 9fffffff   reserved
       a0000000 - bfffffff   reserved
       c0000000 - dfffffff   reserved
       e0000000 - ffffffff   reserved

The first group is a range of numbers administered by Sun Microsystems and
should be identical for all sites.  The second range is for applications
peculiar to a particular site.  This range is intended primarily for
debugging new programs.  When a site develops an application that might be
of general interest, that application should be given an assigned number in
the first range.  Application developers may apply for blocks of RPC
program numbers in the first range by sending electronic mail to
"rpc@sun.com".  The third group is for applications that generate program
numbers dynamically.  The final groups are reserved for future use, and
should not be used.

7.4 Other Uses of the RPC Protocol

The intended use of this protocol is for calling remote procedures.
Normally, each call message is matched with a reply message.  However, the
protocol itself is a message-passing protocol with which other (non-
procedure call) protocols can be implemented.

7.4.1 Batching

Batching is useful when a client wishes to send an arbitrarily large
sequence of call messages to a server.  Batching typically uses reliable
byte stream protocols (like TCP) for its transport.  In the case of
batching, the client never waits for a reply from the server, and the
server does not send replies to batch calls.  A sequence of batch calls is
usually terminated by a legitimate remote procedure call operation in order
to flush the pipeline and get positive acknowledgement.

7.4.2 Broadcast Remote Procedure Calls

In broadcast protocols, the client sends a broadcast call to the network
and waits for numerous replies.  This requires the use of packet-based
protocols (like UDP) as its transport protocol.  Servers that support
broadcast protocols usually respond only when the call is successfully
processed and are silent in the face of errors, but this varies with the
application.  Broadcast calls use the RPCBIND service to achieve their
semantics.  See Appendix A for more information.

8. THE RPC MESSAGE PROTOCOL

This section defines the RPC message protocol in the XDR data description
language [9].





Expires: October 4, 1994                                   [Page 8]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


      enum msg_type {
         CALL  = 0,
         REPLY = 1
      };

A reply to a call message can take on two forms: The message was either
accepted or rejected.

      enum reply_stat {
         MSG_ACCEPTED = 0,
         MSG_DENIED   = 1
      };

Given that a call message was accepted, the following is the status of an
attempt to call a remote procedure.

      enum accept_stat {
         SUCCESS       = 0, /* RPC executed successfully             */
         PROG_UNAVAIL  = 1, /* remote hasn't exported program        */
         PROG_MISMATCH = 2, /* remote can't support version #        */
         PROC_UNAVAIL  = 3, /* program can't support procedure       */
         GARBAGE_ARGS  = 4, /* procedure can't decode params         */
         SYSTEM_ERR    = 5  /* errors like memory allocation failure */
      };

Reasons why a call message was rejected:

      enum reject_stat {
         RPC_MISMATCH = 0, /* RPC version number != 2          */
         AUTH_ERROR = 1    /* remote can't authenticate caller */
      };

Why authentication failed:

      enum auth_stat {
         AUTH_OK           = 0,  /* success                          */
         /*
          * failed at remote end
          */
         AUTH_BADCRED      = 1,  /* bad credential (seal broken)     */
         AUTH_REJECTEDCRED = 2,  /* client must begin new session    */
         AUTH_BADVERF      = 3,  /* bad verifier (seal broken)       */
         AUTH_REJECTEDVERF = 4,  /* verifier expired or replayed     */
         AUTH_TOOWEAK      = 5,  /* rejected for security reasons    */
         /*
          * failed locally
          */
         AUTH_INVALIDRESP  = 6,  /* bogus response verifier          */
         AUTH_FAILED       = 7,  /* reason unknown                   */
         /*
          * kerberos specific errors
          */
         AUTH_KERB_GENERIC = 8,  /* kerberos generic error           */



Expires: October 4, 1994                                   [Page 9]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


         AUTH_TIMEEXPIRE   = 9,  /* time of credential expired       */
         AUTH_TKT_FILE     = 10, /* something wrong with ticket file */
         AUTH_DECODE       = 11, /* can't decode authenticator       */
         AUTH_NET_ADDR     = 12, /* wrong net address in ticket      */
      };

The RPC message:

All messages start with a transaction identifier, xid, followed by a two-
armed discriminated union.  The union's discriminant is a msg_type which
switches to one of the two types of the message.  The xid of a REPLY
message always matches that of the initiating CALL message.  NB: The xid
field is only used for clients matching reply messages with call messages
or for servers detecting retransmissions; the service side cannot treat
this id as any type of sequence number.

      struct rpc_msg {
         unsigned int xid;
         union switch (msg_type mtype) {
         case CALL:
            call_body cbody;
         case REPLY:
            reply_body rbody;
         } body;
      };

Body of an RPC call:

In version 2 of the RPC protocol specification, rpcvers must be equal to 2.
The fields prog, vers, and proc specify the remote program, its version
number, and the procedure within the remote program to be called.  After
these fields are two authentication parameters:  cred (authentication
credential) and verf (authentication verifier).  The two authentication
parameters are followed by the parameters to the remote procedure, which
are specified by the specific program protocol.

      struct call_body {
         unsigned int rpcvers;       /* must be equal to two (2) */
         unsigned int prog;
         unsigned int vers;
         unsigned int proc;
         opaque_auth  cred;
         opaque_auth  verf;
         /* procedure specific parameters start here */
      };

Body of a reply to an RPC call:









Expires: October 4, 1994                                  [Page 10]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


      union reply_body switch (reply_stat stat) {
      case MSG_ACCEPTED:
         accepted_reply areply;
      case MSG_DENIED:
         rejected_reply rreply;
      } reply;

Reply to an RPC call that was accepted by the server:

There could be an error even though the call was accepted.  The first field
is an authentication verifier that the server generates in order to
validate itself to the client.  It is followed by a union whose
discriminant is an enum accept_stat.  The SUCCESS arm of the union is
protocol specific.  The PROG_UNAVAIL, PROC_UNAVAIL, GARBAGE_ARGS, and
SYSTEM_ERR arms of the union are void.  The PROG_MISMATCH arm specifies the
lowest and highest version numbers of the remote program supported by the
server.

      struct accepted_reply {
         opaque_auth verf;
         union switch (accept_stat stat) {
         case SUCCESS:
            opaque results[0];
            /*
             * procedure-specific results start here
             */
          case PROG_MISMATCH:
             struct {
                unsigned int low;
                unsigned int high;
             } mismatch_info;
          default:
             /*
              * Void.  Cases include PROG_UNAVAIL, PROC_UNAVAIL,
              * GARBAGE_ARGS, and SYSTEM_ERR.
              */
             void;
          } reply_data;
      };

Reply to an RPC call that was rejected by the server:

The call can be rejected for two reasons: either the server is not running
a compatible version of the RPC protocol (RPC_MISMATCH), or the server
rejects the identity of the caller (AUTH_ERROR). In case of an RPC version
mismatch, the server returns the lowest and highest supported RPC version
numbers.  In case of invalid authentication, failure status is returned.









Expires: October 4, 1994                                  [Page 11]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


      union rejected_reply switch (reject_stat stat) {
      case RPC_MISMATCH:
         struct {
            unsigned int low;
            unsigned int high;
         } mismatch_info;
      case AUTH_ERROR:
         auth_stat stat;
      };

9. AUTHENTICATION PROTOCOLS

As previously stated, authentication parameters are opaque, but open-ended
to the rest of the RPC protocol.  This section defines some "flavors" of
authentication implemented at (and supported by) Sun.  Other sites are free
to invent new authentication types, with the same rules of flavor number
assignment as there is for program number assignment.  The "flavor" of a
credential or verifier refers to the value of the "flavor" field in the
opaque_auth structure.  Flavor numbers, like RPC program numbers, are also
administered by Sun, and developers may assign new flavor numbers by
applying through electronic mail to "rpc@sun.com".  Credentials and
verifiers are represented as variable length opaque data (the "body" field
in the opaque_auth structure).

9.1 Null Authentication

Often calls must be made where the client does not care about its identity
or the server does not care who the client is.  In this case, the flavor of
the RPC message's credential, verifier, and reply verifier is "AUTH_NONE".
Opaque data associated with "AUTH_NONE" is undefined.  It is recommended
that the length of the opaque data be zero.

9.2 System Authentication

The client may wish to identify itself, for example, as it is identified on
a UNIX(tm) system.  The flavor of the client credential is "AUTH_SYS".  The
opaque data constituting the credential encodes the following structure:

      struct authsys_parms {
         unsigned int stamp;
         string machinename&lt;255&gt;;
         unsigned int uid;
         unsigned int gid;
         unsigned int gids&lt;16&gt;;
      };

The "stamp" is an arbitrary ID which the caller machine may generate.  The
"machinename" is the name of the caller's machine (like "krypton").  The
"uid" is the caller's effective user ID.  The "gid" is the caller's
effective group ID.  The "gids" is a counted array of groups which contain
the caller as a member.  The verifier accompanying the credential should
have "AUTH_NONE" flavor value (defined above).  Note this credential is
only unique within a particular domain of machine names, uids, and gids.



Expires: October 4, 1994                                  [Page 12]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


The flavor value of the verifier received in the reply message from the
server may be "AUTH_NONE" or "AUTH_SHORT".  In the case of "AUTH_SHORT",
the bytes of the reply verifier's string encode an opaque structure.  This
new opaque structure may now be passed to the server instead of the
original "AUTH_SYS" flavor credential.  The server may keep a cache which
maps shorthand opaque structures (passed back by way of an "AUTH_SHORT"
style reply verifier) to the original credentials of the caller.  The
caller can save network bandwidth and server cpu cycles by using the
shorthand credential.

The server may flush the shorthand opaque structure at any time.  If this
happens, the remote procedure call message will be rejected due to an
authentication error.  The reason for the failure will be
"AUTH_REJECTEDCRED".  At this point, the client may wish to try the
original "AUTH_SYS" style of credential.

9.3 DES Authentication

System authentication suffers from three major problems:

(1) The naming is too UNIX(tm) oriented.  (2) There is no universal name,
uid, and gid space.  (3) There is no verifier, so authentication can easily
be faked by
    building an appropriate credential.

DES authentication attempts to address these problems.

9.3.1 Naming

The first problem is handled by addressing the client by a simple string of
characters instead of by an operating system specific integer.  This string
of characters is known as the "netname" or network name of the client. The
server is not allowed to interpret the contents of the client's name in any
other way except to identify the client.  Thus, netnames should be unique
for every client in the Internet.

It is up to each operating system's implementation of DES authentication to
generate netnames for its users that insure this uniqueness when they call
upon remote servers.  Operating systems already know how to distinguish
users local to their systems. It is usually a simple matter to extend this
mechanism to the network.  For example, a UNIX(tm) user at Sun with a user
ID of 515 might be assigned the following netname: "unix.515@sun.com".
This netname contains three items that serve to insure it is unique.  Going
backwards, there is only one naming domain called "sun.com" in the
Internet.  Within this domain, there is only one UNIX(tm) user with user ID
515.  However, there may be another user on another operating system, for
example VMS, within the same naming domain that, by coincidence, happens to
have the same user ID. To insure that these two users can be distinguished
we add the operating system name. So one user is "unix.515@sun.com" and the
other is "vms.515@sun.com".  The first field is actually a naming method
rather than an operating system name.  It happens that today there is
almost a one-to-one correspondence between naming methods and operating
systems.  If the world could agree on a naming standard, the first field



Expires: October 4, 1994                                  [Page 13]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


could be the name of that standard, instead of an operating system name.

9.3.2 DES Authentication Verifiers

Unlike System authentication, DES authentication does have a verifier so
the server can validate the client's credential (and vice-versa).  The
contents of this verifier is primarily an encrypted timestamp.  The server
can decrypt this timestamp, and if it is within an accepted "window"
relative to the real time, then the client must have encrypted it
correctly.  The only way the client could encrypt it correctly is to know
the "conversation key" of the RPC session, and if the client knows the
conversation key, then it must be the real client.

The conversation key is a DES [5] key which the client generates and passes
to the server in the first RPC call of a session.  The conversation key is
encrypted using a public key scheme in this first transaction.  The
particular public key scheme used in DES authentication is Diffie-Hellman
[3] with 192-bit keys.  The details of this encryption method are described
later.

The client and the server need the same notion of the current time in order
for all of this to work, perhaps by using the Network Time Protocol [4].
If network time synchronization cannot be guaranteed, then the client can
determine the server's time before beginning the conversation using a
simpler time request protocol.  The RPCBIND service supports a simple time
request protocol - see Appendix A.

The way a server determines if a client timestamp is valid is somewhat
complicated. For any other transaction but the first, the server just
checks for two things:

(1) the timestamp is greater than the one  previously seen from the same
client.  (2) the timestamp has not expired.

A timestamp is expired if the server's time is later than the sum of the
client's timestamp plus what is known as the client's "window".  The
"window" is a number the client passes (encrypted) to the server in its
first transaction.  You can think of it as a lifetime for the credential.

In the first transaction, the server checks only that the timestamp has not
expired.  Also, as an added check, the client sends an encrypted item in
the first transaction known as the "window verifier" which must be equal to
the window minus 1, or the server will reject the credential.

The client too must check the verifier returned from the server to be sure
it is legitimate.  The server sends back to the client the timestamp it
received from the client, minus one second, encrypted with the conversation
key.  If the client gets anything different than this, it will reject it.

9.3.3 Nicknames and Clock Synchronization

After the first transaction, the server's DES authentication subsystem
returns in its verifier to the client an integer "nickname" which the



Expires: October 4, 1994                                  [Page 14]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


client may use in its further transactions instead of passing its netname.
The nickname could be an index into a table on the server which stores for
each client its netname, decrypted conversation key and window.

Though they originally were synchronized, the client's and server's clocks
can get out of synchronization again.  When this happens the client RPC
subsystem may receive an "RPC_AUTHERROR" error at which point it should
attempt to resynchronize.

A client may still get the "RPC_AUTHERROR" error even though it is
synchronized with the server.  The reason is that the server's nickname
table is a limited size, and it may flush entries whenever it wants.  A
client should resend its original credential in this case and the server
will give it a new nickname.  If a server crashes, the entire nickname
table gets flushed, and all clients will have to resend their original
credentials.

9.3.4 DES Authentication Protocol Specification

There are two kinds of credentials: one in which the client uses its full
network name, and one in which it uses its "nickname" (just an unsigned
integer) given to it by the server.  The client must use its fullname in
its first transaction with the server, in which the server will return to
the client its nickname.  The client may use its nickname in all further
transactions with the server. There is no requirement to use the nickname,
but it is wise to use it for performance reasons.

The following definitions are used for describing the protocol:

   enum authdes_namekind {
      ADN_FULLNAME = 0,
      ADN_NICKNAME = 1
   };

   typedef opaque des_block[8]; /* 64-bit block of encrypted data */

   const MAXNETNAMELEN = 255;   /* maximum length of a netname */

The flavor used for all DES authentication credentials and verifiers is
"AUTH_DES".  The opaque data constituting the client credential encodes the
following structure:

union authdes_cred switch (authdes_namekind namekind) {
case ADN_FULLNAME:
   authdes_fullname fullname;
case ADN_NICKNAME:
   authdes_nickname nickname;
};

The opaque data constituting a verifier that accompanies a client
credential encodes the following structure:





Expires: October 4, 1994                                  [Page 15]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


union authdes_verf switch (authdes_namekind namekind) {
case ADN_FULLNAME:
   authdes_fullname_verf fullname_verf;
case ADN_NICKNAME:
   authdes_nickname_verf nickname_verf;
};

The opaque data constituting a verifier returned by a server in response to
a client request encodes the following structure:

struct authdes_server_verf;

These structures are described in detail below.

9.3.4.1 The Full Network Name Credential and Verifier (Client)

First, the client fills out the following structure:

   +---------------------------------------------------------------+
   |   timestamp   |  timestamp    |               |               |
   |   seconds     | micro seconds |    window     |  window - 1   |
   |   32 bits     |    32 bits    |    32 bits    |   32 bits     |
   +---------------------------------------------------------------+
   0              31              63              95             127

The fields are stored in XDR (external data representation) format.  The
timestamp encodes the time since midnight, January 1, 1970.  These 128 bits
of data are then encrypted in the DES CBC mode, using the conversation key
for the session, and with an initialization vector of 0.  This yields:

   +---------------------------------------------------------------+
   |               T               |               |               |
   |     T1               T2       |      W1       |     W2        |
   |   32 bits     |    32 bits    |    32 bits    |   32 bits     |
   +---------------------------------------------------------------+
   0              31              63              95             127

where T1, T2, W1, and W2 are all 32-bit quantities, and have some
correspondence to the original quantities occupying their positions, but
are now interdependent on each other for proper decryption.  The 64 bit
sequence comprising T1 and T2 is denoted by T.

The full network name credential is represented as follows using XDR
notation:

struct authdes_fullname {
   string name&lt;MAXNETNAMELEN&gt;;  /* netname of client             */
   des_block key;               /* encrypted conversation key    */
   opaque w1[4];                /* W1                            */
};

The conversation key is encrypted using the "common key" using the ECB
mode.  The common key key is a DES key that is derived from the Diffie-



Expires: October 4, 1994                                  [Page 16]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


Hellman public and private keys, and is described later.

The verifier is represented as follows:

struct authdes_fullname_verf {
   des_block timestamp;         /* T (the 64 bits of T1 and T2) */
   opaque w2[4];                /* W2                           */
};

Note that all of the encrypted quantities (key, w1, w2, timestamp) in the
above structures are opaque.

The fullname credential and its associated verifier together contain the
network name of the client, an encrypted conversation key, the window, a
timestamp, and a window verifier that is one less than the window.  The
window is actually the lifetime for the credential.  The server will accept
the credential if the current server time is "within" the time indicated in
the timestamp plus the window.  One way to insure that requests are not
replayed would be for the server to insist that timestamps are greater than
the previous one seen, unless it is the first transaction.

9.3.4.2 The Nickname Credential and Verifier (Client)

In transactions following the first, the client may use the shorter
nickname credential and verifier for efficiency.  First, the client fills
out the following structure:

   +-------------------------------+
   |   timestamp   |  timestamp    |
   |   seconds     | micro seconds |
   |   32 bits     |    32 bits    |
   +-------------------------------+
   0              31              63

The fields are stored in XDR (external data representation) format.  These
64 bits of data are then encrypted in the DES ECB mode, using the
conversation key for the session.  This yields:

   +-------------------------------+
   |     (T1)      |      (T2)     |
   |               T               |
   |             64 bits           |
   +-------------------------------+
   0              31              63

The nickname credential is represented as follows using XDR notation:

struct authdes_nickname {
   unsigned int nickname;       /* nickname returned by server   */
};

The nickname verifier is represented as follows using XDR notation:




Expires: October 4, 1994                                  [Page 17]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


struct authdes_nickname_verf {
   des_block timestamp;         /* T (the 64 bits of T1 and T2) */
   opaque w[4];                 /* Set to zero                  */
};

9.3.4.3 The Nickname Verifier (Server)

The server never returns a credential.  It returns only one kind of
verifier, i.e., the nickname verifier.  This has the following XDR
representation:

struct authdes_server_verf {
   des_block timestamp_verf; /* timestamp verifier (encrypted)    */
   unsigned int nickname;    /* new client nickname (unencrypted) */
};

The timestamp verifier is constructed in exactly the same way as the client
nickname credential.  The server sets the timestamp value to the value the
client sent minus one second and encrypts it in DES ECB mode using the
conversation key.  The server also sends the client a nickname to be used
in future transactions (unencrypted).

9.3.5 Diffie-Hellman Encryption

In this scheme, there are two constants "BASE" and "MODULUS" [3].  The
particular values Sun has chosen for these for the DES authentication
protocol are:

   const BASE = 3;
   const MODULUS = "d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b"

The way this scheme works is best explained by an example.  Suppose there
are two people "A" and "B" who want to send encrypted messages to each
other.  So, A and B both generate "secret" keys at random which they do not
reveal to anyone.  Let these keys be represented as SK(A) and SK(B).  They
also publish in a public directory their "public" keys. These keys are
computed as follows:

   PK(A) = ( BASE ** SK(A) ) mod MODULUS
   PK(B) = ( BASE ** SK(B) ) mod MODULUS

The "**" notation is used here to represent exponentiation. Now, both A and
B can arrive at the "common" key between them, represented here as CK(A,
B), without revealing their secret keys.

A computes:

   CK(A, B) = ( PK(B) ** SK(A)) mod MODULUS

while B computes:

   CK(A, B) = ( PK(A) ** SK(B)) mod MODULUS




Expires: October 4, 1994                                  [Page 18]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


These two can be shown to be equivalent:

   (PK(B) ** SK(A)) mod MODULUS = (PK(A) ** SK(B)) mod MODULUS

We drop the "mod MODULUS" parts and assume modulo arithmetic to simplify
things:

   PK(B) ** SK(A) = PK(A) ** SK(B)

Then, replace PK(B) by what B computed earlier and likewise for PK(A).

   (BASE ** SK(B)) ** SK(A) = (BASE ** SK(A)) ** SK(B)

which leads to:

   BASE ** (SK(A) * SK(B)) = BASE ** (SK(A) * SK(B))

This common key CK(A, B) is not used to encrypt the timestamps used in the
protocol. Rather, it is used only to encrypt a conversation key which is
then used to encrypt the timestamps.  The reason for doing this is to use
the common key as little as possible, for fear that it could be broken.
Breaking the conversation key is a far less damaging, since conversations
are relatively short-lived.

The conversation key is encrypted using 56-bit DES keys, yet the common key
is 192 bits.  To reduce the number of bits, 56 bits are selected from the
common key as follows. The middle-most 8-bytes are selected from the common
key, and then parity is added to the lower order bit of each byte,
producing a 56-bit key with 8 bits of parity.

Only 48 bits of the 8-byte conversation key is used in the DES
Authentication scheme.  The least and most significant bits of each byte of
the conversation key are unused.

9.4 Kerberos-based Authentication

Conceptually, Kerberos-based authentication is very similar to DES based
authentication.  The major difference is, Kerberos-based authentication
takes advantage of the fact that Kerberos tickets have encoded in them the
client name and the conversation key.  This RFC does not describe Kerberos
name syntax, protocols and ticket formats.  The reader is referred to [10],
[11], and [12].

9.4.1 Kerberos-based Authentication Protocol Specification

The Kerberos-based authentication protocol described is based on Kerberos
version 4.

There are two kinds of credentials: one in which the client uses its full
network name, and one in which it uses its "nickname" (just an unsigned
integer) given to it by the server.  The client must use its fullname in
its first transaction with the server, in which the server will return to
the client its nickname.  The client may use its nickname in all further



Expires: October 4, 1994                                  [Page 19]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


transactions with the server. There is no requirement to use the nickname,
but it is wise to use it for performance reasons.

The following definitions are used for describing the protocol:

   enum authkerb_namekind {
      AKN_FULLNAME,
      AKN_NICKNAME
   };

The flavor used for all Kerberos-based authentication credentials and
verifiers is "AUTH_KERB".  The opaque data constituting the client
credential encodes the following structure:

union authkerb_cred switch (authkerb_namekind namekind) {
case AKN_FULLNAME:
   authkerb_fullname fullname;
case AKN_NICKNAME:
   authkerb_nickname nickname;
};

The opaque data constituting a verifier that accompanies a client
credential encodes the following structure:

union authkerb_verf switch (authkerb_namekind namekind) {
case AKN_FULLNAME:
   authkerb_fullname_verf fullname_verf;
case AKN_NICKNAME:
   authkerb_nickname_verf nickname_verf;
};

The opaque data constituting a verifier returned by a server in response to
a client request encodes the following structure:

struct authkerb_server_verf;

These structures are described in detail below.

9.4.1.1 The Full Network Name Credential and Verifier (Client)

First, the client fills out the following structure:

   +---------------------------------------------------------------+
   |   timestamp   |  timestamp    |               |               |
   |   seconds     | micro seconds |    window     |  window - 1   |
   |   32 bits     |    32 bits    |    32 bits    |   32 bits     |
   +---------------------------------------------------------------+
   0              31              63              95             127

The fields are stored in XDR (external data representation) format.  The
timestamp encodes the time since midnight, January 1, 1970.  These 128 bits
of data are then encrypted in the DES CBC mode, using the conversation key
for the session, and with an initialization vector of 0.  This yields:



Expires: October 4, 1994                                  [Page 20]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


   +---------------------------------------------------------------+
   |               T               |               |               |
   |     T1               T2       |      W1       |     W2        |
   |   32 bits     |    32 bits    |    32 bits    |   32 bits     |
   +---------------------------------------------------------------+
   0              31              63              95             127

where T1, T2, W1, and W2 are all 32-bit quantities, and have some
correspondence to the original quantities occupying their positions, but
are now interdependent on each other for proper decryption.  The 64 bit
sequence comprising T1 and T2 is denoted by T.

The full network name credential is represented as follows using XDR
notation:

struct authkerb_fullname {
   opaque ticket&lt;&gt;;         /* kerberos ticket for the server */
   opaque w1[4];            /* W1                             */
};

The verifier is represented as follows:

struct authkerb_fullname_verf {
   des_block timestamp;         /* T (the 64 bits of T1 and T2) */
   opaque w2[4];                /* W2                           */
};

Note that all of the client-encrypted quantities (w1, w2, timestamp) in the
above structures are opaque.  The client does not encrypt the kerberos
ticket for the server.

The fullname credential and its associated verifier together contain the
kerberos ticket (which contains the client name and the conversation key),
the window, a timestamp, and a window verifier that is one less than the
window.  The window is actually the lifetime for the credential.  The
server will accept the credential if the current server time is "within"
the time indicated in the timestamp plus the window.  One way to insure
that requests are not replayed would be for the server to insist that
timestamps are greater than the previous one seen, unless it is the first
transaction.

9.4.1.2 The Nickname Credential and Verifier (Client)

In transactions following the first, the client may use the shorter
nickname credential and verifier for efficiency.  First, the client fills
out the following structure:

   +-------------------------------+
   |   timestamp   |  timestamp    |
   |   seconds     | micro seconds |
   |   32 bits     |    32 bits    |
   +-------------------------------+
   0              31              63



Expires: October 4, 1994                                  [Page 21]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


The fields are stored in XDR (external data representation) format.  These
64 bits of data are then encrypted in the DES ECB mode, using the
conversation key for the session.  This yields:

   +-------------------------------+
   |     (T1)      |      (T2)     |
   |               T               |
   |             64 bits           |
   +-------------------------------+
   0              31              63

The nickname credential is represented as follows using XDR notation:

struct authkerb_nickname {
   unsigned int nickname;       /* nickname returned by server   */
};

The nickname verifier is represented as follows using XDR notation:

struct authkerb_nickname_verf {
   des_block timestamp;         /* T (the 64 bits of T1 and T2) */
   opaque w[4];                 /* Set to zero                  */
};

9.4.1.3 The Nickname Verifier (Server)

The server never returns a credential.  It returns only one kind of
verifier, i.e., the nickname verifier.  This has the following XDR
representation:

struct authkerb_server_verf {
   des_block timestamp_verf; /* timestamp verifier (encrypted)    */
   unsigned int nickname;    /* new client nickname (unencrypted) */
};

The timestamp verifier is constructed in exactly the same way as the client
nickname credential.  The server sets the timestamp value to the value the
client sent minus one second and encrypts it in DES ECB mode using the
conversation key.  The server also sends the client a nickname to be used
in future transactions (unencrypted).


10. RECORD MARKING STANDARD

When RPC messages are passed on top of a byte stream transport protocol
(like TCP), it is necessary to delimit one message from another in order to
detect and possibly recover from protocol errors.  This is called record
marking (RM).  Sun uses this RM/TCP/IP transport for passing RPC messages
on TCP streams.  One RPC message fits into one RM record.

A record is composed of one or more record fragments.  A record fragment is
a four-byte header followed by 0 to (2**31) - 1 bytes of fragment data.
The bytes encode an unsigned binary number; as with XDR integers, the byte



Expires: October 4, 1994                                  [Page 22]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


order is from highest to lowest.  The number encodes two values -- a
boolean which indicates whether the fragment is the last fragment of the
record (bit value 1 implies the fragment is the last fragment) and a 31-bit
unsigned binary value which is the length in bytes of the fragment's data.
The boolean value is the highest-order bit of the header; the length is the
31 low-order bits.  (Note that this record specification is NOT in XDR
standard form!)

11. THE RPC LANGUAGE

Just as there was a need to describe the XDR data-types in a formal
language, there is also need to describe the procedures that operate on
these XDR data-types in a formal language as well.  The RPC Language is an
extension to the XDR language, with the addition of "program", "procedure",
and "version" declarations.  The following example is used to describe the
essence of the language.

11.1 An Example Service Described in the RPC Language

Here is an example of the specification of a simple ping program.

   program PING_PROG {
         /*
          * Latest and greatest version
          */
         version PING_VERS_PINGBACK {
            void
            PINGPROC_NULL(void) = 0;

            /*
             * Ping the client, return the round-trip time
             * (in microseconds). Returns -1 if the operation
             * timed out.
             */
            int
            PINGPROC_PINGBACK(void) = 1;
         } = 2;

         /*
          * Original version
          */
         version PING_VERS_ORIG {
            void
            PINGPROC_NULL(void) = 0;
         } = 1;
      } = 1;

      const PING_VERS = 2;      /* latest version */

The first version described is PING_VERS_PINGBACK with two procedures,
PINGPROC_NULL and PINGPROC_PINGBACK.  PINGPROC_NULL takes no arguments and
returns no results, but it is useful for computing round-trip times from
the client to the server and back again.  By convention, procedure 0 of any



Expires: October 4, 1994                                  [Page 23]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


RPC protocol should have the same semantics, and never require any kind of
authentication.  The second procedure is used for the client to have the
server do a reverse ping operation back to the client, and it returns the
amount of time (in microseconds) that the operation used.  The next
version, PING_VERS_ORIG, is the original version of the protocol and it
does not contain PINGPROC_PINGBACK procedure. It is useful for
compatibility with old client programs, and as this program matures it may
be dropped from the protocol entirely.

11.2 The RPC Language Specification

The RPC language is identical to the XDR language defined in RFC 1014,
except for the added definition of a "program-def" described below.

program-def:
   "program" identifier "{"
      version-def
      version-def *
   "}" "=" constant ";"

version-def:
   "version" identifier "{"
       procedure-def
       procedure-def *
   "}" "=" constant ";"

procedure-def:
   type-specifier identifier "(" type-specifier
     ("," type-specifier )* ")" "=" constant ";"

11.3 Syntax Notes

(1) The following keywords are added and cannot be used as identifiers:
"program" and "version";

(2) A version name cannot occur more than once within the scope of a
program definition. Nor can a version number occur more than once within
the scope of a program definition.

(3) A procedure name cannot occur more than once within the scope of a
version definition. Nor can a procedure number occur more than once within
the scope of version definition.

(4) Program identifiers are in the same name space as constant and type
identifiers.

(5) Only unsigned constants can be assigned to programs, versions and
procedures.

APPENDIX A: RPCBIND PROGRAM PROTOCOL

The RPCBIND program maps RPC program and version numbers to universal
addresses, thus making dynamic binding of remote programs possible.



Expires: October 4, 1994                                  [Page 24]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


Universal addresses are string representations of the transport dependent
addresses.  They are defined by the addressing authority of the given
transport.

The RPCBIND program is bound to a well-known address of each supported
transport, and other programs register their dynamically allocated
transport address with it.  The RPCBIND program then makes those addresses
publicly available.

This is desirable because the range of well-known addresses is very small
for some transports and the number of potential remote programs is very
large.  By running only the RPCBIND service on a well-known address, the
transport addresses of other remote programs can be ascertained by querying
the RPCBIND program.

The RPCBIND program also aids in broadcast RPC.  A given RPC program will
usually have different transport address bindings on different machines, so
there is no way to directly broadcast to all of these programs. The RPCBIND
program, however, does have a well-known address.  So, to broadcast to a
given program, the client actually sends its message to the RPCBIND program
located at the broadcast address. Each instance of the RPCBIND program that
picks up the broadcast then calls the local service specified by the
client.  When the RPCBIND program gets the reply from the local service, it
sends the reply on back to the client.

Versions 3 and 4 of the RPCBIND protocol are described below.  Version 2 is
described separately as part of the Port Mapper protocol specification.

A.1 RPCBIND Protocol Specification (in RPC Language)

/*
 * rpcb_prot.x
 * rpcbind protocol, versions 3 and 4, in RPC Language
 */

/*
 * rpcbind address for TCP/UDP
 */
const RPCB_PORT = 111;

/*
 * A mapping of (program, version, network ID) to address
 */
struct rpcb {
 unsigned long r_prog;    /* program number */
 unsigned long r_vers;    /* version number */
 string r_netid&lt;&gt;;        /* network id */
 string r_addr&lt;&gt;;         /* universal address */
 string r_owner&lt;&gt;;        /* owner of this service */
};

struct rp__list {
 rpcb rpcb_map;



Expires: October 4, 1994                                  [Page 25]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


 struct rp__list *rpcb_next;
};

typedef rp__list *rpcblist_ptr;        /* results of RPCBPROC_DUMP */



/*
 * Arguments of remote calls
 */
struct rpcb_rmtcallargs {
 unsigned long prog;        /* program number */
 unsigned long vers;        /* version number */
 unsigned long proc;        /* procedure number */
 opaque args&lt;&gt;;             /* argument */
};


/*
 * Results of the remote call
 */
struct rpcb_rmtcallres {
 string addr&lt;&gt;;            /* remote universal address */
 opaque results&lt;&gt;;         /* result */
};


/*
 * rpcb_entry contains a merged address of a service on a particular
 * transport, plus associated netconfig information.  A list of rpcb_entry
 * items is returned by RPCBPROC_GETADDRLIST.  The meanings and values used
 * for the r_nc_* fields are given below.
 *
 * The network identifier  (r_nc_netid):
 *   This is a string that represents a local identification for a network.
 *   This is defined by a system administrator based on local conventions,
 *   and cannot be depended on to have the same value on every system.
 *
 * Transport semantics (r_nc_semantics):
 *   This represents the type of transport, and has the following values:
 *     NC_TPI_CLTS     (1)      Connectionless
 *     NC_TPI_COTS     (2)      Connection oriented
 *     NC_TPI_COTS_ORD (3)      Connection oriented with graceful close
 *     NC_TPI_RAW      (4)      Raw transport
 *
 * Protocol family (r_nc_protofmly):
 *   This identifies the family to which the protocol belongs.  The
 *   following values are defined:
 *     NC_NOPROTOFMLY   "-"
 *     NC_LOOPBACK      "loopback"
 *     NC_INET          "inet"
 *     NC_IMPLINK       "implink"
 *     NC_PUP           "pup"



Expires: October 4, 1994                                  [Page 26]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


 *     NC_CHAOS         "chaos"
 *     NC_NS            "ns"
 *     NC_NBS           "nbs"
 *     NC_ECMA          "ecma"
 *     NC_DATAKIT       "datakit"
 *     NC_CCITT         "ccitt"
 *     NC_SNA           "sna"
 *     NC_DECNET        "decnet"
 *     NC_DLI           "dli"
 *     NC_LAT           "lat"
 *     NC_HYLINK        "hylink"
 *     NC_APPLETALK     "appletalk"
 *     NC_NIT           "nit"
 *     NC_IEEE802       "ieee802"
 *     NC_OSI           "osi"
 *     NC_X25           "x25"
 *     NC_OSINET        "osinet"
 *     NC_GOSIP         "gosip"
 *
 * Protocol name (r_nc_proto):
 *   This identifies a protocol within a family.  The following are
 *   currently defined:
 *      NC_NOPROTO      "-"
 *      NC_TCP          "tcp"
 *      NC_UDP          "udp"
 *      NC_ICMP         "icmp"
 */
struct rpcb_entry {
 string          r_maddr&lt;&gt;;            /* merged address of service */
 string          r_nc_netid&lt;&gt;;         /* netid field */
 unsigned long   r_nc_semantics;       /* semantics of transport */
 string          r_nc_protofmly&lt;&gt;;     /* protocol family */
 string          r_nc_proto&lt;&gt;;         /* protocol name */
};

/*
 * A list of addresses supported by a service.
 */
struct rpcb_entry_list {
 rpcb_entry rpcb_entry_map;
 struct rpcb_entry_list *rpcb_entry_next;
};

typedef rpcb_entry_list *rpcb_entry_list_ptr;


/*
 * rpcbind statistics
 */

const rpcb_highproc_2 = RPCBPROC_CALLIT;
const rpcb_highproc_3 = RPCBPROC_TADDR2UADDR;
const rpcb_highproc_4 = RPCBPROC_GETSTAT;



Expires: October 4, 1994                                  [Page 27]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


const RPCBSTAT_HIGHPROC = 13;    /* # of procs in rpcbind V4 plus one */
const RPCBVERS_STAT     = 3;    /* provide only for rpcbind V2, V3 and V4 */
const RPCBVERS_4_STAT   = 2;
const RPCBVERS_3_STAT   = 1;
const RPCBVERS_2_STAT   = 0;

/* Link list of all the stats about getport and getaddr */
struct rpcbs_addrlist {
 unsigned long prog;
 unsigned long vers;
 int success;
 int failure;
 string netid&lt;&gt;;
 struct rpcbs_addrlist *next;
};

/* Link list of all the stats about rmtcall */
struct rpcbs_rmtcalllist {
 unsigned long prog;
 unsigned long vers;
 unsigned long proc;
 int success;
 int failure;
 int indirect;    /* whether callit or indirect */
 string netid&lt;&gt;;
 struct rpcbs_rmtcalllist *next;
};

typedef int rpcbs_proc[RPCBSTAT_HIGHPROC];
typedef rpcbs_addrlist *rpcbs_addrlist_ptr;
typedef rpcbs_rmtcalllist *rpcbs_rmtcalllist_ptr;

struct rpcb_stat {
 rpcbs_proc              info;
 int                     setinfo;
 int                     unsetinfo;
 rpcbs_addrlist_ptr      addrinfo;
 rpcbs_rmtcalllist_ptr   rmtinfo;
};

/*
 * One rpcb_stat structure is returned for each version of rpcbind
 * being monitored.
 */

typedef rpcb_stat rpcb_stat_byvers[RPCBVERS_STAT];

/*
 * netbuf structure, used to store the transport specific form of
 * a universal transport address.
 */
struct netbuf {
 unsigned int maxlen;



Expires: October 4, 1994                                  [Page 28]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


 opaque buf&lt;&gt;;
};


/*
 * rpcbind procedures
 */
program RPCBPROG {
 version RPCBVERS {
     bool
     RPCBPROC_SET(rpcb) = 1;

     bool
     RPCBPROC_UNSET(rpcb) = 2;

     string
     RPCBPROC_GETADDR(rpcb) = 3;

     rpcblist_ptr
     RPCBPROC_DUMP(void) = 4;

     rpcb_rmtcallres
     RPCBPROC_CALLIT(rpcb_rmtcallargs) = 5;

     unsigned int
     RPCBPROC_GETTIME(void) = 6;

     netbuf
     RPCBPROC_UADDR2TADDR(string) = 7;

     string
     RPCBPROC_TADDR2UADDR(netbuf) = 8;
 } = 3;

 version RPCBVERS4 {
     bool
     RPCBPROC_SET(rpcb) = 1;

     bool
     RPCBPROC_UNSET(rpcb) = 2;

     string
     RPCBPROC_GETADDR(rpcb) = 3;

     rpcblist_ptr
     RPCBPROC_DUMP(void) = 4;

     /*
      * NOTE: RPCBPROC_BCAST has the same functionality as CALLIT;
      * the new name is intended to indicate that this
      * procedure should be used for broadcast RPC, and
      * RPCBPROC_INDIRECT should be used for indirect calls.
      */



Expires: October 4, 1994                                  [Page 29]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


     rpcb_rmtcallres
     RPCBPROC_BCAST(rpcb_rmtcallargs) = RPCBPROC_CALLIT;

     unsigned int
     RPCBPROC_GETTIME(void) = 6;

     netbuf
     RPCBPROC_UADDR2TADDR(string) = 7;

     string
     RPCBPROC_TADDR2UADDR(netbuf) = 8;

     string
     RPCBPROC_GETVERSADDR(rpcb) = 9;

     rpcb_rmtcallres
     RPCBPROC_INDIRECT(rpcb_rmtcallargs) = 10;

     rpcb_entry_list_ptr
     RPCBPROC_GETADDRLIST(rpcb) = 11;

     rpcb_stat_byvers
     RPCBPROC_GETSTAT(void) = 12;
 } = 4;
} = 100000;

A.2 RPCBIND Operation

RPCBIND is contacted by way of an assigned address specific to the
transport being used.  For TCP/IP and UDP/IP, for example, it is port
number 111.  Each transport has such an assigned, well-known address.  The
following is a description of each of the procedures supported by RPCBIND.

A.2.1 RPCBIND Version 3

RPCBPROC_SET:

When a program first becomes available on a machine, it registers itself
with RPCBIND running on the same machine.  The program passes its program
number "r_prog", version number "r_vers", network identifier "r_netid",
universal address "r_addr", and the owner of the service "r_owner".  The
procedure returns a boolean response whose value is TRUE if the procedure
successfully established the mapping and FALSE otherwise.  The procedure
refuses to establish a mapping if one already exists for the ordered set
("r_prog", "r_vers", "r_netid").  Note that neither "r_netid" nor "r_addr"
can be NULL, and that "r_netid" should be a valid network identifier on the
machine making the call.

RPCBPROC_UNSET:

When a program becomes unavailable, it should unregister itself with the
RPCBIND program on the same machine.  The parameters and results have
meanings identical to those of RPCBPROC_SET.  The mapping of the ("r_prog",



Expires: October 4, 1994                                  [Page 30]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


"r_vers", "r_netid") tuple with "r_addr" is deleted.  If "r_netid" is NULL,
all mappings specified by the ordered set ("r_prog", "r_vers", *) and the
corresponding universal addresses are deleted.  Only the owner of the
service or the super-user is allowed to unset a service.

RPCBPROC_GETADDR:

Given a program number "r_prog", version number "r_vers", and network
identifier  "r_netid", this procedure returns the universal address on
which the program is awaiting call requests.  The "r_netid" field of the
argument is ignored and the "r_netid" is inferred from the network
identifier of the transport on which the request came in.

RPCBPROC_DUMP:

This procedure lists all entries in RPCBIND's database.  The procedure
takes no parameters and returns a list of program, version, network
identifier, and universal addresses.

RPCBPROC_CALLIT:

This procedure allows a caller to call another remote procedure on the same
machine without knowing the remote procedure's universal address.  It is
intended for supporting broadcasts to arbitrary remote programs via
RPCBIND's universal address.  The parameters "prog", "vers", "proc", and
args are the program number, version number, procedure number, and
parameters of the remote procedure.

Note - This procedure only sends a response if the procedure was
successfully executed and is silent (no response) otherwise.

The procedure returns the remote program's universal address, and the
results of the remote procedure.

RPCBPROC_GETTIME:

This procedure returns the local time on its own machine in seconds since
the midnight of the First day of January, 1970.

RPCBPROC_UADDR2TADDR:

This procedure converts universal addresses to transport specific
addresses.

RPCBPROC_TADDR2UADDR:

This procedure converts transport specific addresses to universal
addresses.

A.2.2 RPCBIND, Version 4

Version 4 of the RPCBIND protocol includes all of the above procedures, and
adds several additional ones.



Expires: October 4, 1994                                  [Page 31]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


RPCBPROC_BCAST:

This procedure is identical to the version 3 RPCBPROC_CALLIT procedure.
The new name indicates that the procedure should be used for broadcast RPCs
only.  RPCBPROC_INDIRECT, defined below, should be used for indirect RPC
calls.

RPCBPROC_GETVERSADDR:

This procedure is similar to RPCBPROC_GETADDR.  The difference is the
"r_vers" field of the rpcb structure can be used to specify the version of
interest.  If that version is not registered, no address is returned.

RPCBPROC_INDIRECT:

Similar to RPCBPROC_CALLIT.  Instead of being silent about errors (such as
the program not being registered on the system), this procedure returns an
indication of the error.  This procedure should not be used for broadcast
RPC. It is intended to be used with indirect RPC calls only.

RPCBPROC_GETADDRLIST:

This procedure returns a list of addresses for the given rpcb entry.  The
client may be able use the results to determine alternate transports that
it can use to communicate with the server.

RPCBPROC_GETSTAT:

This procedure returns statistics on the activity of the RPCBIND server.
The information lists the number and kind of requests the server has
received.

Note - All procedures except RPCBPROC_SET and RPCBPROC_UNSET can be called
by clients running on a machine other than a machine on which RPCBIND is
running.  RPCBIND only accepts RPCBPROC_SET and RPCBPROC_UNSET requests by
clients running on the same machine as the RPCBIND program.

APPENDIX B: PORT MAPPER PROGRAM PROTOCOL

The port mapper program maps RPC program and version numbers to transport-
specific port numbers.  This program makes dynamic binding of remote
programs possible.  The port mapper protocol differs from the newer RPCBIND
protocols in that it is transport specific in its address handling.

B.1 Port Mapper Protocol Specification (in RPC Language)

      const PMAP_PORT = 111;      /* portmapper port number */

A mapping of (program, version, protocol) to port number:

      struct mapping {
         unsigned int prog;
         unsigned int vers;



Expires: October 4, 1994                                  [Page 32]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


         unsigned int prot;
         unsigned int port;
      };

Supported values for the "prot" field:

      const IPPROTO_TCP = 6;      /* protocol number for TCP/IP */
      const IPPROTO_UDP = 17;     /* protocol number for UDP/IP */

A list of mappings:

      struct *pmaplist {
         mapping map;
         pmaplist next;
      };

Arguments to callit:

      struct call_args {
         unsigned int prog;
         unsigned int vers;
         unsigned int proc;
         opaque args&lt;&gt;;
      };

Results of callit:

      struct call_result {
         unsigned int port;
         opaque res&lt;&gt;;
      };

Port mapper procedures:

      program PMAP_PROG {
         version PMAP_VERS {
            void
            PMAPPROC_NULL(void)         = 0;

            bool
            PMAPPROC_SET(mapping)       = 1;

            bool
            PMAPPROC_UNSET(mapping)     = 2;

            unsigned int
            PMAPPROC_GETPORT(mapping)   = 3;

            pmaplist
            PMAPPROC_DUMP(void)         = 4;

            call_result
            PMAPPROC_CALLIT(call_args)  = 5;



Expires: October 4, 1994                                  [Page 33]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


         } = 2;
      } = 100000;

B.2 Port Mapper Operation

The portmapper program currently supports two protocols (UDP and TCP).  The
portmapper is contacted by talking to it on assigned port number 111
(SUNRPC) on either of these protocols.

The following is a description of each of the portmapper procedures:

PMAPPROC_NULL:

This procedure does no work.  By convention, procedure zero of any protocol
takes no parameters and returns no results.

PMAPPROC_SET:

When a program first becomes available on a machine, it registers itself
with the port mapper program on the same machine.  The program passes its
program number "prog", version number "vers", transport protocol number
"prot", and the port "port" on which it awaits service request.  The
procedure returns a boolean reply whose value is "TRUE" if the procedure
successfully established the mapping and "FALSE" otherwise.  The procedure
refuses to establish a mapping if one already exists for the tuple "(prog,
vers, prot)".

PMAPPROC_UNSET:

When a program becomes unavailable, it should unregister itself with the
port mapper program on the same machine.  The parameters and results have
meanings identical to those of "PMAPPROC_SET".  The protocol and port
number fields of the argument are ignored.

PMAPPROC_GETPORT:

Given a program number "prog", version number "vers", and transport
protocol number "prot", this procedure returns the port number on which the
program is awaiting call requests.  A port value of zeros means the program
has not been registered.  The "port" field of the argument is ignored.

PMAPPROC_DUMP:

This procedure enumerates all entries in the port mapper's database.  The
procedure takes no parameters and returns a list of program, version,
protocol, and port values.

PMAPPROC_CALLIT:

This procedure allows a client to call another remote procedure on the same
machine without knowing the remote procedure's port number.  It is intended
for supporting broadcasts to arbitrary remote programs via the well-known
port mapper's port.  The parameters "prog", "vers", "proc", and the bytes



Expires: October 4, 1994                                  [Page 34]





INTERNET DRAFT   Remote Procedure Call Protocol Version 2          4-Mar-94


of "args" are the program number, version number, procedure number, and
parameters of the remote procedure.  Note:

(1) This procedure only sends a reply if the procedure was successfully
executed and is silent (no reply) otherwise.

(2) The port mapper communicates with the remote program using UDP only.

The procedure returns the remote program's port number, and the reply is
the reply of the remote procedure.

REFERENCES

[1]  Birrell, A. D.  &amp; Nelson, B. J., "Implementing Remote Procedure
     Calls", XEROX CSL-83-7, October 1983.

[2]  Cheriton, D., "VMTP: Versatile Message Transaction Protocol",
     Preliminary Version 0.3, Stanford University, January 1987.

[3]  Diffie &amp; Hellman, "New Directions in Cryptography", IEEE
     Transactions on Information Theory IT-22, November 1976.

[4]  Mills, D., "Network Time Protocol", RFC-958, M/A-COM Linkabit,
     September 1985.

[5]  National Bureau of Standards, "Data Encryption Standard", Federal
     Information Processing Standards Publication 46, January 1977.

[6]  Postel, J., "Transmission Control Protocol - DARPA Internet
     Program Protocol Specification", RFC-793, Information Sciences
     Institute, September 1981.

[7]  Postel, J., "User Datagram Protocol", RFC-768, Information
     Sciences Institute, August 1980.

[8]  Reynolds, J., and Postel, J., "Assigned Numbers", RFC-1010,
     Information Sciences Institute, May 1987.

[9]  Sun Microsystems, "XDR: External Data Representation Standard",
     RFC-1014, June 1987.

[10] Miller, S., Neuman, C., Schiller, J., and  J. Saltzer, "Section
     E.2.1: Kerberos  Authentication and Authorization System",
     M.I.T. Project Athena, Cambridge, Massachusetts, December 21,
     1987.

[11] Steiner, J., Neuman, C., and J. Schiller, "Kerberos: An
     Authentication Service for Open Network Systems", pp. 191-202 in
     Usenix Conference Proceedings, Dallas, Texas, February, 1988.

[12] Kohl, J. and Neuman, C., "The Kerberos Network Authentication
     Service (V5)", RFC-1510, September 1993.




Expires: October 4, 1994                                  [Page 35]

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="01228" HREF="msg01228.html">Secure RPC?</A></STRONG>
<UL><LI><EM>From:</EM> danisch@ira.uka.de (Hadmut Danisch)</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg01226.html">RE: Secure RPC?</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg01207.html">public key of Lady Ada ???</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg01210.html">Re: Secure RPC?</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg01226.html">RE: Secure RPC?</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#01215"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#01215"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
