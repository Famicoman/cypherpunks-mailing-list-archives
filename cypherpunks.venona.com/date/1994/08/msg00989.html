<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: NSA Spy Machine and DES -->
<!--X-From-R13: wqqNnvxv.qrzba.pb.hx (Xvz Rvkba) -->
<!--X-Date: Tue, 23 Aug 94 06:03:28 PDT -->
<!--X-Message-Id: 7148@aiki.demon.co.uk -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: NSA Spy Machine and DES</TITLE>
<LINK REV="made" HREF="mailto:jdd@aiki.demon.co.uk">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00981.html">Date Prev</A>][<A HREF="msg00976.html">Date Next</A>][<A HREF="msg00929.html">Thread Prev</A>][<A HREF="msg01066.html">Thread Next</A>][<A HREF="index.html#00989">Date Index</A>][<A HREF="threads.html#00989">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: NSA Spy Machine and DES</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:ianf@simple.sydney.sgi.com">ianf@simple.sydney.sgi.com</A></LI>
<LI><em>Subject</em>: Re: NSA Spy Machine and DES</LI>
<LI><em>From</em>: <A HREF="mailto:jdd@aiki.demon.co.uk">jdd@aiki.demon.co.uk</A> (Jim Dixon)</LI>
<LI><em>Date</em>: Tue, 23 Aug 94 11:16:28 GMT</LI>
<LI><em>Cc</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Reply-To</em>: <A HREF="mailto:jdd@aiki.demon.co.uk">jdd@aiki.demon.co.uk</A></LI>
<LI><em>Sender</em>: <A HREF="mailto:owner%2Dcypherpunks@toad.com">owner-cypherpunks@toad.com</A></LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
In message &lt;<A HREF="msg00929.html">9408221018.ZM4791@simple.sydney.sgi.com</A>&gt; Ian Farquhar writes:
&gt; On Aug 18,  8:13pm, Jim Dixon wrote:
&gt; &gt;In message &lt;<A HREF="msg00802.html">9408190809.ZM4528@simple.sydney.sgi.com</A>&gt; Ian Farquhar writes:
&gt; &gt;&gt;Actually, I would be surprised if the "SIMD" processors were not a huge
&gt; &gt;&gt;array of reprogrammable FPGA's, quite possibly Xilinx's.  The possibilities
&gt; &gt;&gt;of a large array of these chips, each with local memory, is quite
&gt; &gt;&gt;interesting.  I have personally seen an array of 64 Xilinx chips in a DEC
&gt; PeRL
&gt; &gt;&gt;box doing RSA, at speeds similar or better to almost all available custom
&gt; &gt;&gt;hardware implementations of the cipher.
&gt; 
&gt; &gt;The delays in getting data on and off the chip are too large and the amount
&gt; &gt;of space wasted in redundant functions is too great.
&gt; 
&gt; That is a rather sweeping statement.  Want to back this up with some facts
&gt; and figures from real FPGA implementations?  Certainly the early bit-slice
&gt; designs you mention later on did suffer from these problems, but FPGA's
&gt; bear little relationship to those rather venerable devices.

1.  I have been using various kinds of programmable logic devices in
    designs for years.	In doing such designs, you avoid using one device
    to drive another, because the effect of this is usually to increase
    your delays by 80% or so.  There are a number of reasons for this.
    (a) You almost invariably duplicate functions if logic is spread over
    more than one chip.  (b) The impedance and capacitance of the device
    pins and PCB tracks are far greater than those on-chip.  As a result,
    for example, the setup time on an input flip-flop on an Actel A14100A
    is 3ns, but the setup time on an internal flip-flop is 0.8ns, about 75%
    less.  In general off chip delays are an order of magnitude higher
    than on chip delays.

    FPGAs use longer internal routes than would be necessary on an ASIC
    and as I understand it the fuse impedance is a significant problem
    Both of these factors increase capacitance and impedance, slowing
    down the circuits.

2.  The redundancy should be completely obvious.  An FPGA is programmable.
    It has circuits whose sole function is to program the device.  These
    occupy space.  They cover the entire device.  Once the device is
    programmed they serve no purpose.

    An ASIC also has a fairly high level of redundancy, because logic is
    assembled out of elementary logic blocks.

    A custom circuit, such as a microprocessor, has very little redundancy.

    To understand the effect of this, go price a 64K bit static RAM. ($5?)
    Then calculate the cost of implementing the same function in FPGAs,
    especially with comparable speed.

&gt; &gt;You might prototype
&gt; &gt;it using FPGAs, but even this is unlikely.  Why not just buy one of the
&gt; &gt;existing SIMD processors and simulate your target system?
&gt;
&gt; Because the FPGA solution is obviously less flexible, but a hell of a lot
&gt; faster than software simulation of another architecture.  In this application
&gt; speed will win every time.

For prototyping, speed is not usually a major consideration.  What you
are trying to do is to get the system to work, you are debugging it.

&gt; &gt; People used to build fast processors out of separate chips (bit slices).
&gt; &gt; They don't do that any more because it's too slow and too expensive if you
&gt; &gt; are building in volume.
&gt; 
&gt; But this application is NOT building in volume.

It was my understanding that the project involved on the order of 10^4 to
10^6 chips.

If the size of the system is small and the number of chips is low, then
the use of FPGAs would be justifiable (and I myself have justified this
in another context).

&gt;						    And yes, people do still
&gt; built multichip CPU's: most traditional supercomputing and mainframe vendors
&gt; for a start.  Indeed, I would be surprised if this application didn't design
&gt; it's own FPGA (for ease of interfacing with the comms network for a start),

? what do you mean by 'design [an] FPGA' ?  Do you just mean "do the design
using FPGAs" -- easy --  or literally, "design a new type of FPGA"?  This
would be very expensive and pointless.	Commercial designers are almost
always going to do something cheaper and better than something done under
a government contract.

&gt; but I'd argue that a SIMD configuration of reconfigurable FPGA arrays (ie.
&gt; a fixed array of reconfigurable arrays) would be an awesome system for
&gt; many problems that the NSA would deal with.

Why SIMD?  Why not a reconfigurable architecture as well?

-- 
+-----------------------------------+--------------------------------------+
|  Jim Dixon&lt;jdd@aiki.demon.co.uk&gt;  |	    Compuserve: 100114,1027	   |
|AIKI Parallel Systems Ltd + parallel processing hardware &amp; software design|
|	     voice +44 272 291 316  | fax +44 272 272 015		   |
+-----------------------------------+--------------------------------------+

</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00981.html">Nuclear Weapons Material</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00976.html">Re: Nuclear Weapons Material</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00929.html">Re: NSA Spy Machine and DES</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg01066.html">Re: NSA Spy Machine and DES</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00989"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00989"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
