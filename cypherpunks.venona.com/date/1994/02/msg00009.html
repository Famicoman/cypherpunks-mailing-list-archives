<!-- MHonArc v2.4.3 -->
<!--X-Subject: Re: PGP keyid collisions? -->
<!--X-From-R13: Vny <usvaarlNfuryy.cbegny.pbz> -->
<!--X-Date: Tue, 1 Feb 94 08:10:34 PST -->
<!--X-Message-Id: 199402011607.IAA22359@jobe.shell.portal.com -->
<!--X-Content-Type: text/plain -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<HTML>
<HEAD>
<TITLE>Re: PGP keyid collisions?</TITLE>
<LINK REV="made" HREF="mailto:hfinney@shell.portal.com">
</HEAD>
<BODY>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00013.html">Date Prev</A>][<A HREF="msg00027.html">Date Next</A>][<A HREF="msg00004.html">Thread Prev</A>][<A HREF="msg00000.html">Thread Next</A>][<A HREF="index.html#00009">Date Index</A>][<A HREF="threads.html#00009">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>Re: PGP keyid collisions?</H1>
<HR>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<UL>
<LI><em>To</em>: <A HREF="mailto:cypherpunks@toad.com">cypherpunks@toad.com</A></LI>
<LI><em>Subject</em>: Re: PGP keyid collisions?</LI>
<LI><em>From</em>: Hal &lt;<A HREF="mailto:hfinney@shell.portal.com">hfinney@shell.portal.com</A>&gt;</LI>
<LI><em>Date</em>: Tue, 1 Feb 1994 08:07:50 -0800</LI>
</UL>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
From: wcs@anchor.ho.att.com (bill.stewart@pleasantonca.ncr.com +1-510-484-6204)
&gt; Hal points out that brute-forcing a 24-bit Key-ID isn't all that hard;
&gt; the usual formulas tell you what fraction of numbers are prime in the 
&gt; desired range, though without looking them up I'd expect it would take
&gt; around 2**30 - 2**35 tries to find a specific one; I suppose this 
&gt; means the NSA has already done it :-)

Right, but the point is that you have to search for a prime q anyway;
PGP's algorithm is basically to repeat q += 2 until you find a q which
is prime.  It uses a sieve to speed this up a lot.  I was pointing out
that you can basically change the 2 to a 2^24, still use a sieve, and
find a key just about as fast.  So matching an existing key ID should not
take much if any longer than just generating a PGP key in the first place.

&gt; &gt; I understand there is already at least one 24-bit collision on the
&gt; &gt; public key servers, not unexpected given a few thousand keys.
&gt; 
&gt; I assume PGP does the right thing, except in cases of pilot error
&gt; (e.g. doing key lookup by KeyID) ?  Even if it does, this has
&gt; some design impact on systems using random public-private key generation
&gt; for meet-me remailer cutouts.
&gt; 		Bill

PGP actually uses a 64-bit key ID internally, only displaying the lower
24 bits for conciseness.  It would be practically impossible to get a
64-bit key ID collision by accident (well, almost impossible, anyway).
However, the technique I mentioned could easily generate such collisions.
PGP does check for the case of matching key ID and does something, but I
forget what.  24-bit key ID matches shouldn't have any effect except for,
as Bill says, extracting/deleting keys based on key ID.

Hal


</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00013.html">Re: archiving on inet</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00027.html">Archiving mail-lists...</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00004.html">PGP keyid collisions?</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00000.html">BlackNet - what is it?</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00009"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00009"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>
